"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

// node_modules/vscode-jsonrpc/lib/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var toString = Object.prototype.toString;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return toString.call(value) === "[object String]";
    }
    exports.string = string;
    function number(value) {
      return toString.call(value) === "[object Number]";
    }
    exports.number = number;
    function error(value) {
      return toString.call(value) === "[object Error]";
    }
    exports.error = error;
    function func(value) {
      return toString.call(value) === "[object Function]";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every(function(elem) {
        return string(elem);
      });
    }
    exports.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/messages.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.serverErrorEnd = -32e3;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.RequestCancelled = -32800;
      ErrorCodes2.MessageWriteError = 1;
      ErrorCodes2.MessageReadError = 2;
    })(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
    var ResponseError = function(_super) {
      __extends(ResponseError2, _super);
      function ResponseError2(code, message, data) {
        var _this = _super.call(this, message) || this;
        _this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        if (data !== void 0) {
          _this.data = data;
        }
        Object.setPrototypeOf(_this, ResponseError2.prototype);
        return _this;
      }
      ResponseError2.prototype.toJson = function() {
        var result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        ;
        return result;
      };
      return ResponseError2;
    }(Error);
    exports.ResponseError = ResponseError;
    var AbstractMessageType = function() {
      function AbstractMessageType2(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
      }
      Object.defineProperty(AbstractMessageType2.prototype, "method", {
        get: function() {
          return this._method;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(AbstractMessageType2.prototype, "numberOfParams", {
        get: function() {
          return this._numberOfParams;
        },
        enumerable: true,
        configurable: true
      });
      return AbstractMessageType2;
    }();
    exports.AbstractMessageType = AbstractMessageType;
    var RequestType0 = function(_super) {
      __extends(RequestType02, _super);
      function RequestType02(method) {
        var _this = _super.call(this, method, 0) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType02;
    }(AbstractMessageType);
    exports.RequestType0 = RequestType0;
    var RequestType = function(_super) {
      __extends(RequestType10, _super);
      function RequestType10(method) {
        var _this = _super.call(this, method, 1) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType10;
    }(AbstractMessageType);
    exports.RequestType = RequestType;
    var RequestType1 = function(_super) {
      __extends(RequestType12, _super);
      function RequestType12(method) {
        var _this = _super.call(this, method, 1) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType12;
    }(AbstractMessageType);
    exports.RequestType1 = RequestType1;
    var RequestType2 = function(_super) {
      __extends(RequestType22, _super);
      function RequestType22(method) {
        var _this = _super.call(this, method, 2) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType22;
    }(AbstractMessageType);
    exports.RequestType2 = RequestType2;
    var RequestType3 = function(_super) {
      __extends(RequestType32, _super);
      function RequestType32(method) {
        var _this = _super.call(this, method, 3) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType32;
    }(AbstractMessageType);
    exports.RequestType3 = RequestType3;
    var RequestType4 = function(_super) {
      __extends(RequestType42, _super);
      function RequestType42(method) {
        var _this = _super.call(this, method, 4) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType42;
    }(AbstractMessageType);
    exports.RequestType4 = RequestType4;
    var RequestType5 = function(_super) {
      __extends(RequestType52, _super);
      function RequestType52(method) {
        var _this = _super.call(this, method, 5) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType52;
    }(AbstractMessageType);
    exports.RequestType5 = RequestType5;
    var RequestType6 = function(_super) {
      __extends(RequestType62, _super);
      function RequestType62(method) {
        var _this = _super.call(this, method, 6) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType62;
    }(AbstractMessageType);
    exports.RequestType6 = RequestType6;
    var RequestType7 = function(_super) {
      __extends(RequestType72, _super);
      function RequestType72(method) {
        var _this = _super.call(this, method, 7) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType72;
    }(AbstractMessageType);
    exports.RequestType7 = RequestType7;
    var RequestType8 = function(_super) {
      __extends(RequestType82, _super);
      function RequestType82(method) {
        var _this = _super.call(this, method, 8) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType82;
    }(AbstractMessageType);
    exports.RequestType8 = RequestType8;
    var RequestType9 = function(_super) {
      __extends(RequestType92, _super);
      function RequestType92(method) {
        var _this = _super.call(this, method, 9) || this;
        _this._ = void 0;
        return _this;
      }
      return RequestType92;
    }(AbstractMessageType);
    exports.RequestType9 = RequestType9;
    var NotificationType = function(_super) {
      __extends(NotificationType10, _super);
      function NotificationType10(method) {
        var _this = _super.call(this, method, 1) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType10;
    }(AbstractMessageType);
    exports.NotificationType = NotificationType;
    var NotificationType0 = function(_super) {
      __extends(NotificationType02, _super);
      function NotificationType02(method) {
        var _this = _super.call(this, method, 0) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType02;
    }(AbstractMessageType);
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = function(_super) {
      __extends(NotificationType12, _super);
      function NotificationType12(method) {
        var _this = _super.call(this, method, 1) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType12;
    }(AbstractMessageType);
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = function(_super) {
      __extends(NotificationType22, _super);
      function NotificationType22(method) {
        var _this = _super.call(this, method, 2) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType22;
    }(AbstractMessageType);
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = function(_super) {
      __extends(NotificationType32, _super);
      function NotificationType32(method) {
        var _this = _super.call(this, method, 3) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType32;
    }(AbstractMessageType);
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = function(_super) {
      __extends(NotificationType42, _super);
      function NotificationType42(method) {
        var _this = _super.call(this, method, 4) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType42;
    }(AbstractMessageType);
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = function(_super) {
      __extends(NotificationType52, _super);
      function NotificationType52(method) {
        var _this = _super.call(this, method, 5) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType52;
    }(AbstractMessageType);
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = function(_super) {
      __extends(NotificationType62, _super);
      function NotificationType62(method) {
        var _this = _super.call(this, method, 6) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType62;
    }(AbstractMessageType);
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = function(_super) {
      __extends(NotificationType72, _super);
      function NotificationType72(method) {
        var _this = _super.call(this, method, 7) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType72;
    }(AbstractMessageType);
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = function(_super) {
      __extends(NotificationType82, _super);
      function NotificationType82(method) {
        var _this = _super.call(this, method, 8) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType82;
    }(AbstractMessageType);
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = function(_super) {
      __extends(NotificationType92, _super);
      function NotificationType92(method) {
        var _this = _super.call(this, method, 9) || this;
        _this._ = void 0;
        return _this;
      }
      return NotificationType92;
    }(AbstractMessageType);
    exports.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      var candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      var candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      var candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports.isResponseMessage = isResponseMessage;
  }
});

// node_modules/vscode-jsonrpc/lib/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports.Disposable || (exports.Disposable = {}));
    var Event;
    (function(Event2) {
      var _disposable = { dispose: function() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports.Event || (exports.Event = {}));
    var CallbackList = function() {
      function CallbackList2() {
      }
      CallbackList2.prototype.add = function(callback, context, bucket) {
        var _this = this;
        if (context === void 0) {
          context = null;
        }
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: function() {
            return _this.remove(callback, context);
          } });
        }
      };
      CallbackList2.prototype.remove = function(callback, context) {
        if (context === void 0) {
          context = null;
        }
        if (!this._callbacks) {
          return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      };
      CallbackList2.prototype.invoke = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._callbacks) {
          return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            console.error(e);
          }
        }
        return ret;
      };
      CallbackList2.prototype.isEmpty = function() {
        return !this._callbacks || this._callbacks.length === 0;
      };
      CallbackList2.prototype.dispose = function() {
        this._callbacks = void 0;
        this._contexts = void 0;
      };
      return CallbackList2;
    }();
    var Emitter = function() {
      function Emitter2(_options) {
        this._options = _options;
      }
      Object.defineProperty(Emitter2.prototype, "event", {
        get: function() {
          var _this = this;
          if (!this._event) {
            this._event = function(listener, thisArgs, disposables) {
              if (!_this._callbacks) {
                _this._callbacks = new CallbackList();
              }
              if (_this._options && _this._options.onFirstListenerAdd && _this._callbacks.isEmpty()) {
                _this._options.onFirstListenerAdd(_this);
              }
              _this._callbacks.add(listener, thisArgs);
              var result;
              result = {
                dispose: function() {
                  _this._callbacks.remove(listener, thisArgs);
                  result.dispose = Emitter2._noop;
                  if (_this._options && _this._options.onLastListenerRemove && _this._callbacks.isEmpty()) {
                    _this._options.onLastListenerRemove(_this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        },
        enumerable: true,
        configurable: true
      });
      Emitter2.prototype.fire = function(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      };
      Emitter2.prototype.dispose = function() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      };
      Emitter2._noop = function() {
      };
      return Emitter2;
    }();
    exports.Emitter = Emitter;
  }
});

// node_modules/vscode-jsonrpc/lib/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/messageReader.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var DefaultSize = 8192;
    var CR = new Buffer("\r", "ascii")[0];
    var LF = new Buffer("\n", "ascii")[0];
    var CRLF = "\r\n";
    var MessageBuffer = function() {
      function MessageBuffer2(encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        this.encoding = encoding;
        this.index = 0;
        this.buffer = new Buffer(DefaultSize);
      }
      MessageBuffer2.prototype.append = function(chunk) {
        var toAppend = chunk;
        if (typeof chunk == "string") {
          var str = chunk;
          var bufferLen = Buffer.byteLength(str, this.encoding);
          toAppend = new Buffer(bufferLen);
          toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
          toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        } else {
          var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
          if (this.index === 0) {
            this.buffer = new Buffer(newSize);
            toAppend.copy(this.buffer, 0, 0, toAppend.length);
          } else {
            this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
          }
        }
        this.index += toAppend.length;
      };
      MessageBuffer2.prototype.tryReadHeaders = function() {
        var result = void 0;
        var current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
          current++;
        }
        if (current + 3 >= this.index) {
          return result;
        }
        result = /* @__PURE__ */ Object.create(null);
        var headers = this.buffer.toString("ascii", 0, current).split(CRLF);
        headers.forEach(function(header) {
          var index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          var key = header.substr(0, index);
          var value = header.substr(index + 1).trim();
          result[key] = value;
        });
        var nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
      };
      MessageBuffer2.prototype.tryReadContent = function(length) {
        if (this.index < length) {
          return null;
        }
        var result = this.buffer.toString(this.encoding, 0, length);
        var nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
      };
      Object.defineProperty(MessageBuffer2.prototype, "numberOfBytes", {
        get: function() {
          return this.index;
        },
        enumerable: true,
        configurable: true
      });
      return MessageBuffer2;
    }();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        var candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
    var AbstractMessageReader = function() {
      function AbstractMessageReader2() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      AbstractMessageReader2.prototype.dispose = function() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      };
      Object.defineProperty(AbstractMessageReader2.prototype, "onError", {
        get: function() {
          return this.errorEmitter.event;
        },
        enumerable: true,
        configurable: true
      });
      AbstractMessageReader2.prototype.fireError = function(error) {
        this.errorEmitter.fire(this.asError(error));
      };
      Object.defineProperty(AbstractMessageReader2.prototype, "onClose", {
        get: function() {
          return this.closeEmitter.event;
        },
        enumerable: true,
        configurable: true
      });
      AbstractMessageReader2.prototype.fireClose = function() {
        this.closeEmitter.fire(void 0);
      };
      Object.defineProperty(AbstractMessageReader2.prototype, "onPartialMessage", {
        get: function() {
          return this.partialMessageEmitter.event;
        },
        enumerable: true,
        configurable: true
      });
      AbstractMessageReader2.prototype.firePartialMessage = function(info) {
        this.partialMessageEmitter.fire(info);
      };
      AbstractMessageReader2.prototype.asError = function(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error("Reader recevied error. Reason: " + (Is.string(error.message) ? error.message : "unknown"));
        }
      };
      return AbstractMessageReader2;
    }();
    exports.AbstractMessageReader = AbstractMessageReader;
    var StreamMessageReader = function(_super) {
      __extends(StreamMessageReader2, _super);
      function StreamMessageReader2(readable, encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        var _this = _super.call(this) || this;
        _this.readable = readable;
        _this.buffer = new MessageBuffer(encoding);
        _this._partialMessageTimeout = 1e4;
        return _this;
      }
      Object.defineProperty(StreamMessageReader2.prototype, "partialMessageTimeout", {
        get: function() {
          return this._partialMessageTimeout;
        },
        set: function(timeout) {
          this._partialMessageTimeout = timeout;
        },
        enumerable: true,
        configurable: true
      });
      StreamMessageReader2.prototype.listen = function(callback) {
        var _this = this;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        this.readable.on("data", function(data) {
          _this.onData(data);
        });
        this.readable.on("error", function(error) {
          return _this.fireError(error);
        });
        this.readable.on("close", function() {
          return _this.fireClose();
        });
      };
      StreamMessageReader2.prototype.onData = function(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            var headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            var contentLength = headers["Content-Length"];
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            var length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          var msg = this.buffer.tryReadContent(this.nextMessageLength);
          if (msg === null) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          this.messageToken++;
          var json = JSON.parse(msg);
          this.callback(json);
        }
      };
      StreamMessageReader2.prototype.clearPartialMessageTimer = function() {
        if (this.partialMessageTimer) {
          clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      };
      StreamMessageReader2.prototype.setPartialMessageTimer = function() {
        var _this = this;
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = setTimeout(function(token, timeout) {
          _this.partialMessageTimer = void 0;
          if (token === _this.messageToken) {
            _this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            _this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      };
      return StreamMessageReader2;
    }(AbstractMessageReader);
    exports.StreamMessageReader = StreamMessageReader;
    var IPCMessageReader = function(_super) {
      __extends(IPCMessageReader2, _super);
      function IPCMessageReader2(process2) {
        var _this = _super.call(this) || this;
        _this.process = process2;
        var eventEmitter = _this.process;
        eventEmitter.on("error", function(error) {
          return _this.fireError(error);
        });
        eventEmitter.on("close", function() {
          return _this.fireClose();
        });
        return _this;
      }
      IPCMessageReader2.prototype.listen = function(callback) {
        this.process.on("message", callback);
      };
      return IPCMessageReader2;
    }(AbstractMessageReader);
    exports.IPCMessageReader = IPCMessageReader;
    var SocketMessageReader = function(_super) {
      __extends(SocketMessageReader2, _super);
      function SocketMessageReader2(socket, encoding) {
        if (encoding === void 0) {
          encoding = "utf-8";
        }
        return _super.call(this, socket, encoding) || this;
      }
      return SocketMessageReader2;
    }(StreamMessageReader);
    exports.SocketMessageReader = SocketMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/messageWriter.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        var candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
    var AbstractMessageWriter = function() {
      function AbstractMessageWriter2() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      AbstractMessageWriter2.prototype.dispose = function() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      };
      Object.defineProperty(AbstractMessageWriter2.prototype, "onError", {
        get: function() {
          return this.errorEmitter.event;
        },
        enumerable: true,
        configurable: true
      });
      AbstractMessageWriter2.prototype.fireError = function(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      };
      Object.defineProperty(AbstractMessageWriter2.prototype, "onClose", {
        get: function() {
          return this.closeEmitter.event;
        },
        enumerable: true,
        configurable: true
      });
      AbstractMessageWriter2.prototype.fireClose = function() {
        this.closeEmitter.fire(void 0);
      };
      AbstractMessageWriter2.prototype.asError = function(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error("Writer recevied error. Reason: " + (Is.string(error.message) ? error.message : "unknown"));
        }
      };
      return AbstractMessageWriter2;
    }();
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var StreamMessageWriter = function(_super) {
      __extends(StreamMessageWriter2, _super);
      function StreamMessageWriter2(writable, encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        var _this = _super.call(this) || this;
        _this.writable = writable;
        _this.encoding = encoding;
        _this.errorCount = 0;
        _this.writable.on("error", function(error) {
          return _this.fireError(error);
        });
        _this.writable.on("close", function() {
          return _this.fireClose();
        });
        return _this;
      }
      StreamMessageWriter2.prototype.write = function(msg) {
        var json = JSON.stringify(msg);
        var contentLength = Buffer.byteLength(json, this.encoding);
        var headers = [
          ContentLength,
          contentLength.toString(),
          CRLF,
          CRLF
        ];
        try {
          this.writable.write(headers.join(""), "ascii");
          this.writable.write(json, this.encoding);
          this.errorCount = 0;
        } catch (error) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
      };
      return StreamMessageWriter2;
    }(AbstractMessageWriter);
    exports.StreamMessageWriter = StreamMessageWriter;
    var IPCMessageWriter = function(_super) {
      __extends(IPCMessageWriter2, _super);
      function IPCMessageWriter2(process2) {
        var _this = _super.call(this) || this;
        _this.process = process2;
        _this.errorCount = 0;
        _this.queue = [];
        _this.sending = false;
        var eventEmitter = _this.process;
        eventEmitter.on("error", function(error) {
          return _this.fireError(error);
        });
        eventEmitter.on("close", function() {
          return _this.fireClose;
        });
        return _this;
      }
      IPCMessageWriter2.prototype.write = function(msg) {
        if (!this.sending && this.queue.length === 0) {
          this.doWriteMessage(msg);
        } else {
          this.queue.push(msg);
        }
      };
      IPCMessageWriter2.prototype.doWriteMessage = function(msg) {
        var _this = this;
        try {
          if (this.process.send) {
            this.sending = true;
            this.process.send(msg, void 0, void 0, function(error) {
              _this.sending = false;
              if (error) {
                _this.errorCount++;
                _this.fireError(error, msg, _this.errorCount);
              } else {
                _this.errorCount = 0;
              }
              if (_this.queue.length > 0) {
                _this.doWriteMessage(_this.queue.shift());
              }
            });
          }
        } catch (error) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
      };
      return IPCMessageWriter2;
    }(AbstractMessageWriter);
    exports.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageWriter = function(_super) {
      __extends(SocketMessageWriter2, _super);
      function SocketMessageWriter2(socket, encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        var _this = _super.call(this) || this;
        _this.socket = socket;
        _this.queue = [];
        _this.sending = false;
        _this.encoding = encoding;
        _this.errorCount = 0;
        _this.socket.on("error", function(error) {
          return _this.fireError(error);
        });
        _this.socket.on("close", function() {
          return _this.fireClose();
        });
        return _this;
      }
      SocketMessageWriter2.prototype.write = function(msg) {
        if (!this.sending && this.queue.length === 0) {
          this.doWriteMessage(msg);
        } else {
          this.queue.push(msg);
        }
      };
      SocketMessageWriter2.prototype.doWriteMessage = function(msg) {
        var _this = this;
        var json = JSON.stringify(msg);
        var contentLength = Buffer.byteLength(json, this.encoding);
        var headers = [
          ContentLength,
          contentLength.toString(),
          CRLF,
          CRLF
        ];
        try {
          this.sending = true;
          this.socket.write(headers.join(""), "ascii", function(error) {
            if (error) {
              _this.handleError(error, msg);
            }
            try {
              _this.socket.write(json, _this.encoding, function(error2) {
                _this.sending = false;
                if (error2) {
                  _this.handleError(error2, msg);
                } else {
                  _this.errorCount = 0;
                }
                if (_this.queue.length > 0) {
                  _this.doWriteMessage(_this.queue.shift());
                }
              });
            } catch (error2) {
              _this.handleError(error2, msg);
            }
          });
        } catch (error) {
          this.handleError(error, msg);
        }
      };
      SocketMessageWriter2.prototype.handleError = function(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      };
      return SocketMessageWriter2;
    }(AbstractMessageWriter);
    exports.SocketMessageWriter = SocketMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    var Is = require_is();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        var candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      var handle = setTimeout(callback.bind(context), 0);
      return { dispose: function() {
        clearTimeout(handle);
      } };
    });
    var MutableToken = function() {
      function MutableToken2() {
        this._isCancelled = false;
      }
      MutableToken2.prototype.cancel = function() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this._emitter = void 0;
          }
        }
      };
      Object.defineProperty(MutableToken2.prototype, "isCancellationRequested", {
        get: function() {
          return this._isCancelled;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(MutableToken2.prototype, "onCancellationRequested", {
        get: function() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        },
        enumerable: true,
        configurable: true
      });
      return MutableToken2;
    }();
    var CancellationTokenSource = function() {
      function CancellationTokenSource2() {
      }
      Object.defineProperty(CancellationTokenSource2.prototype, "token", {
        get: function() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        },
        enumerable: true,
        configurable: true
      });
      CancellationTokenSource2.prototype.cancel = function() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      };
      CancellationTokenSource2.prototype.dispose = function() {
        this.cancel();
      };
      return CancellationTokenSource2;
    }();
    exports.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/linkedMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.Last = 2;
    })(Touch = exports.Touch || (exports.Touch = {}));
    var LinkedMap = function() {
      function LinkedMap2() {
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      LinkedMap2.prototype.clear = function() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      };
      LinkedMap2.prototype.isEmpty = function() {
        return !this._head && !this._tail;
      };
      Object.defineProperty(LinkedMap2.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: true,
        configurable: true
      });
      LinkedMap2.prototype.has = function(key) {
        return this._map.has(key);
      };
      LinkedMap2.prototype.get = function(key) {
        var item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        return item.value;
      };
      LinkedMap2.prototype.set = function(key, value, touch) {
        if (touch === void 0) {
          touch = Touch.None;
        }
        var item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
      };
      LinkedMap2.prototype.delete = function(key) {
        var item = this._map.get(key);
        if (!item) {
          return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
      };
      LinkedMap2.prototype.shift = function() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        var item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      };
      LinkedMap2.prototype.forEach = function(callbackfn, thisArg) {
        var current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          current = current.next;
        }
      };
      LinkedMap2.prototype.forEachReverse = function(callbackfn, thisArg) {
        var current = this._tail;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          current = current.previous;
        }
      };
      LinkedMap2.prototype.values = function() {
        var result = [];
        var current = this._head;
        while (current) {
          result.push(current.value);
          current = current.next;
        }
        return result;
      };
      LinkedMap2.prototype.keys = function() {
        var result = [];
        var current = this._head;
        while (current) {
          result.push(current.key);
          current = current.next;
        }
        return result;
      };
      LinkedMap2.prototype.addItemFirst = function(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
      };
      LinkedMap2.prototype.addItemLast = function(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
      };
      LinkedMap2.prototype.removeItem = function(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          this._head = item.next;
        } else if (item === this._tail) {
          this._tail = item.previous;
        } else {
          var next = item.next;
          var previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
      };
      LinkedMap2.prototype.touch = function(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          var next = item.next;
          var previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          var next = item.next;
          var previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
        }
      };
      return LinkedMap2;
    }();
    exports.LinkedMap = LinkedMap;
  }
});

// node_modules/vscode-jsonrpc/lib/pipeSupport.js
var require_pipeSupport = __commonJS({
  "node_modules/vscode-jsonrpc/lib/pipeSupport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path_1 = require("path");
    var os_1 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var messageReader_1 = require_messageReader();
    var messageWriter_1 = require_messageWriter();
    function generateRandomPipeName() {
      var randomSuffix = crypto_1.randomBytes(21).toString("hex");
      if (process.platform === "win32") {
        return "\\\\.\\pipe\\vscode-jsonrpc-" + randomSuffix + "-sock";
      } else {
        return path_1.join(os_1.tmpdir(), "vscode-" + randomSuffix + ".sock");
      }
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding) {
      if (encoding === void 0) {
        encoding = "utf-8";
      }
      var connectResolve;
      var connected = new Promise(function(resolve2, _reject) {
        connectResolve = resolve2;
      });
      return new Promise(function(resolve2, reject) {
        var server2 = net_1.createServer(function(socket) {
          server2.close();
          connectResolve([
            new messageReader_1.SocketMessageReader(socket, encoding),
            new messageWriter_1.SocketMessageWriter(socket, encoding)
          ]);
        });
        server2.on("error", reject);
        server2.listen(pipeName, function() {
          server2.removeListener("error", reject);
          resolve2({
            onConnected: function() {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding) {
      if (encoding === void 0) {
        encoding = "utf-8";
      }
      var socket = net_1.createConnection(pipeName);
      return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
  }
});

// node_modules/vscode-jsonrpc/lib/socketSupport.js
var require_socketSupport = __commonJS({
  "node_modules/vscode-jsonrpc/lib/socketSupport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = require("net");
    var messageReader_1 = require_messageReader();
    var messageWriter_1 = require_messageWriter();
    function createClientSocketTransport(port, encoding) {
      if (encoding === void 0) {
        encoding = "utf-8";
      }
      var connectResolve;
      var connected = new Promise(function(resolve2, _reject) {
        connectResolve = resolve2;
      });
      return new Promise(function(resolve2, reject) {
        var server2 = net_1.createServer(function(socket) {
          server2.close();
          connectResolve([
            new messageReader_1.SocketMessageReader(socket, encoding),
            new messageWriter_1.SocketMessageWriter(socket, encoding)
          ]);
        });
        server2.on("error", reject);
        server2.listen(port, "127.0.0.1", function() {
          server2.removeListener("error", reject);
          resolve2({
            onConnected: function() {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding) {
      if (encoding === void 0) {
        encoding = "utf-8";
      }
      var socket = net_1.createConnection(port, "127.0.0.1");
      return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
  }
});

// node_modules/vscode-jsonrpc/lib/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/main.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var Is = require_is();
    var messages_1 = require_messages();
    exports.RequestType = messages_1.RequestType;
    exports.RequestType0 = messages_1.RequestType0;
    exports.RequestType1 = messages_1.RequestType1;
    exports.RequestType2 = messages_1.RequestType2;
    exports.RequestType3 = messages_1.RequestType3;
    exports.RequestType4 = messages_1.RequestType4;
    exports.RequestType5 = messages_1.RequestType5;
    exports.RequestType6 = messages_1.RequestType6;
    exports.RequestType7 = messages_1.RequestType7;
    exports.RequestType8 = messages_1.RequestType8;
    exports.RequestType9 = messages_1.RequestType9;
    exports.ResponseError = messages_1.ResponseError;
    exports.ErrorCodes = messages_1.ErrorCodes;
    exports.NotificationType = messages_1.NotificationType;
    exports.NotificationType0 = messages_1.NotificationType0;
    exports.NotificationType1 = messages_1.NotificationType1;
    exports.NotificationType2 = messages_1.NotificationType2;
    exports.NotificationType3 = messages_1.NotificationType3;
    exports.NotificationType4 = messages_1.NotificationType4;
    exports.NotificationType5 = messages_1.NotificationType5;
    exports.NotificationType6 = messages_1.NotificationType6;
    exports.NotificationType7 = messages_1.NotificationType7;
    exports.NotificationType8 = messages_1.NotificationType8;
    exports.NotificationType9 = messages_1.NotificationType9;
    var messageReader_1 = require_messageReader();
    exports.MessageReader = messageReader_1.MessageReader;
    exports.StreamMessageReader = messageReader_1.StreamMessageReader;
    exports.IPCMessageReader = messageReader_1.IPCMessageReader;
    exports.SocketMessageReader = messageReader_1.SocketMessageReader;
    var messageWriter_1 = require_messageWriter();
    exports.MessageWriter = messageWriter_1.MessageWriter;
    exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
    exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
    exports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
    var events_1 = require_events();
    exports.Disposable = events_1.Disposable;
    exports.Event = events_1.Event;
    exports.Emitter = events_1.Emitter;
    var cancellation_1 = require_cancellation();
    exports.CancellationTokenSource = cancellation_1.CancellationTokenSource;
    exports.CancellationToken = cancellation_1.CancellationToken;
    var linkedMap_1 = require_linkedMap();
    __export(require_pipeSupport());
    __export(require_socketSupport());
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    exports.NullLogger = Object.freeze({
      error: function() {
      },
      warn: function() {
      },
      info: function() {
      },
      log: function() {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Verbose"] = 2] = "Verbose";
    })(Trace = exports.Trace || (exports.Trace = {}));
    (function(Trace2) {
      function fromString(value) {
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports.Trace || (exports.Trace = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTraceNotification");
    })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTraceNotification");
    })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
    var ConnectionError = function(_super) {
      __extends(ConnectionError2, _super);
      function ConnectionError2(code, message) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        Object.setPrototypeOf(_this, ConnectionError2.prototype);
        return _this;
      }
      return ConnectionError2;
    }(Error);
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        var candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
      var sequenceNumber = 0;
      var notificationSquenceNumber = 0;
      var unknownResponseSquenceNumber = 0;
      var version = "2.0";
      var starRequestHandler = void 0;
      var requestHandlers = /* @__PURE__ */ Object.create(null);
      var starNotificationHandler = void 0;
      var notificationHandlers = /* @__PURE__ */ Object.create(null);
      var timer;
      var messageQueue = new linkedMap_1.LinkedMap();
      var responsePromises = /* @__PURE__ */ Object.create(null);
      var requestTokens = /* @__PURE__ */ Object.create(null);
      var trace2 = Trace.Off;
      var tracer;
      var state = ConnectionState.New;
      var errorEmitter = new events_1.Emitter();
      var closeEmitter = new events_1.Emitter();
      var unhandledNotificationEmitter = new events_1.Emitter();
      var disposeEmitter = new events_1.Emitter();
      function createRequestQueueKey(id) {
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      ;
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = setImmediate(function() {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        var message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      var callback = function(message) {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            var key = createRequestQueueKey(message.params.id);
            var toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              var response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          var message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          var message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          var message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        var element = requestHandlers[requestMessage.method];
        var type;
        var requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        var startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          var cancellationSource = new cancellation_1.CancellationTokenSource();
          var tokenKey_1 = String(requestMessage.id);
          requestTokens[tokenKey_1] = cancellationSource;
          try {
            var handlerResult = void 0;
            if (requestMessage.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
              handlerResult = requestHandler ? requestHandler(cancellationSource.token) : starRequestHandler(requestMessage.method, cancellationSource.token);
            } else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
              handlerResult = requestHandler ? requestHandler.apply(void 0, requestMessage.params.concat([cancellationSource.token])) : starRequestHandler.apply(void 0, [requestMessage.method].concat(requestMessage.params, [cancellationSource.token]));
            } else {
              handlerResult = requestHandler ? requestHandler(requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            var promise = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey_1];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then(function(resultOrError) {
                delete requestTokens[tokenKey_1];
                reply(resultOrError, requestMessage.method, startTime);
              }, function(error) {
                delete requestTokens[tokenKey_1];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed with message: " + error.message), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed unexpectedly without providing any details."), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey_1];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey_1];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed with message: " + error.message), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed unexpectedly without providing any details."), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, "Unhandled method " + requestMessage.method), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error("Received response message without id: Error is: \n" + JSON.stringify(responseMessage.error, void 0, 4));
          } else {
            logger.error("Received response message without id. No further error information provided.");
          }
        } else {
          var key = String(responseMessage.id);
          var responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                var error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error2) {
              if (error2.message) {
                logger.error("Response handler '" + responsePromise.method + "' failed with message: " + error2.message);
              } else {
                logger.error("Response handler '" + responsePromise.method + "' failed unexpectedly.");
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        var type = void 0;
        var notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = function(params) {
            var id = params.id;
            var source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          var element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (message.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
              notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
            } else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
              notificationHandler ? notificationHandler.apply(void 0, message.params) : starNotificationHandler.apply(void 0, [message.method].concat(message.params));
            } else {
              notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error("Notification handler '" + message.method + "' failed with message: " + error.message);
            } else {
              logger.error("Notification handler '" + message.method + "' failed unexpectedly.");
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error("Received message which is neither a response nor a notification message:\n" + JSON.stringify(message, null, 4));
        var responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          var key = String(responseMessage.id);
          var responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        var data = void 0;
        if (trace2 === Trace.Verbose && message.params) {
          data = "Params: " + JSON.stringify(message.params, null, 4) + "\n\n";
        }
        tracer.log("Sending request '" + message.method + " - (" + message.id + ")'.", data);
      }
      function traceSendNotification(message) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        var data = void 0;
        if (trace2 === Trace.Verbose) {
          if (message.params) {
            data = "Params: " + JSON.stringify(message.params, null, 4) + "\n\n";
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log("Sending notification '" + message.method + "'.", data);
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        var data = void 0;
        if (trace2 === Trace.Verbose) {
          if (message.error && message.error.data) {
            data = "Error data: " + JSON.stringify(message.error.data, null, 4) + "\n\n";
          } else {
            if (message.result) {
              data = "Result: " + JSON.stringify(message.result, null, 4) + "\n\n";
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        tracer.log("Sending response '" + method + " - (" + message.id + ")'. Processing request took " + (Date.now() - startTime) + "ms", data);
      }
      function traceReceivedRequest(message) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        var data = void 0;
        if (trace2 === Trace.Verbose && message.params) {
          data = "Params: " + JSON.stringify(message.params, null, 4) + "\n\n";
        }
        tracer.log("Received request '" + message.method + " - (" + message.id + ")'.", data);
      }
      function traceReceivedNotification(message) {
        if (trace2 === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        var data = void 0;
        if (trace2 === Trace.Verbose) {
          if (message.params) {
            data = "Params: " + JSON.stringify(message.params, null, 4) + "\n\n";
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log("Received notification '" + message.method + "'.", data);
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        var data = void 0;
        if (trace2 === Trace.Verbose) {
          if (message.error && message.error.data) {
            data = "Error data: " + JSON.stringify(message.error.data, null, 4) + "\n\n";
          } else {
            if (message.result) {
              data = "Result: " + JSON.stringify(message.result, null, 4) + "\n\n";
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        if (responsePromise) {
          var error = message.error ? " Request failed: " + message.error.message + " (" + message.error.code + ")." : "";
          tracer.log("Received response '" + responsePromise.method + " - (" + message.id + ")' in " + (Date.now() - responsePromise.timerStart) + "ms." + error, data);
        } else {
          tracer.log("Received response " + message.id + " without active response promise.", data);
        }
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function computeMessageParams(type, params) {
        var result;
        var numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = null;
            break;
          case 1:
            result = undefinedToNull(params[0]);
            break;
          default:
            result = [];
            for (var i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (var i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      var connection2 = {
        sendNotification: function(type) {
          var params = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
          }
          throwIfClosedOrDisposed();
          var method;
          var messageParams;
          if (Is.string(type)) {
            method = type;
            switch (params.length) {
              case 0:
                messageParams = null;
                break;
              case 1:
                messageParams = params[0];
                break;
              default:
                messageParams = params;
                break;
            }
          } else {
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          var notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: function(type, handler) {
          throwIfClosedOrDisposed();
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              notificationHandlers[type] = { type: void 0, handler };
            } else {
              notificationHandlers[type.method] = { type, handler };
            }
          }
        },
        sendRequest: function(type) {
          var params = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
          }
          throwIfClosedOrDisposed();
          throwIfNotListening();
          var method;
          var messageParams;
          var token = void 0;
          if (Is.string(type)) {
            method = type;
            switch (params.length) {
              case 0:
                messageParams = null;
                break;
              case 1:
                if (cancellation_1.CancellationToken.is(params[0])) {
                  messageParams = null;
                  token = params[0];
                } else {
                  messageParams = undefinedToNull(params[0]);
                }
                break;
              default:
                var last = params.length - 1;
                if (cancellation_1.CancellationToken.is(params[last])) {
                  token = params[last];
                  if (params.length === 2) {
                    messageParams = undefinedToNull(params[0]);
                  } else {
                    messageParams = params.slice(0, last).map(function(value) {
                      return undefinedToNull(value);
                    });
                  }
                } else {
                  messageParams = params.map(function(value) {
                    return undefinedToNull(value);
                  });
                }
                break;
            }
          } else {
            method = type.method;
            messageParams = computeMessageParams(type, params);
            var numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          var id = sequenceNumber++;
          var result = new Promise(function(resolve2, reject) {
            var requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            var responsePromise = { method, timerStart: Date.now(), resolve: resolve2, reject };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          if (token) {
            token.onCancellationRequested(function() {
              connection2.sendNotification(CancelNotification.type, { id });
            });
          }
          return result;
        },
        onRequest: function(type, handler) {
          throwIfClosedOrDisposed();
          if (Is.func(type)) {
            starRequestHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              requestHandlers[type] = { type: void 0, handler };
            } else {
              requestHandlers[type.method] = { type, handler };
            }
          }
        },
        trace: function(_value, _tracer, sendNotification) {
          if (sendNotification === void 0) {
            sendNotification = false;
          }
          trace2 = _value;
          if (trace2 === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (sendNotification && !isClosed() && !isDisposed()) {
            connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: function() {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          var error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach(function(key) {
            responsePromises[key].reject(error);
          });
          responsePromises = /* @__PURE__ */ Object.create(null);
          requestTokens = /* @__PURE__ */ Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: function() {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: function() {
          console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, function(params) {
        if (trace2 === Trace.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace2 === Trace.Verbose ? params.verbose : void 0);
      });
      return connection2;
    }
    function isMessageReader(value) {
      return value.listen !== void 0 && value.read === void 0;
    }
    function isMessageWriter(value) {
      return value.write !== void 0 && value.end === void 0;
    }
    function createMessageConnection(input, output, logger, strategy) {
      if (!logger) {
        logger = exports.NullLogger;
      }
      var reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
      var writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
      return _createMessageConnection(reader, writer, logger, strategy);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-languageserver-types/lib/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/main.js"(exports, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var Position;
      (function(Position2) {
        function create(line, character) {
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
        }
        Position2.is = is;
      })(Position = exports2.Position || (exports2.Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range = exports2.Range || (exports2.Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location = exports2.Location || (exports2.Location = {}));
      var DiagnosticSeverity2;
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3.Error = 1;
        DiagnosticSeverity3.Warning = 2;
        DiagnosticSeverity3.Information = 3;
        DiagnosticSeverity3.Hint = 4;
      })(DiagnosticSeverity2 = exports2.DiagnosticSeverity || (exports2.DiagnosticSeverity = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.string(candidate.source) || Is.undefined(candidate.source));
        }
        Diagnostic2.is = is;
      })(Diagnostic = exports2.Diagnostic || (exports2.Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.title);
        }
        Command2.is = is;
      })(Command = exports2.Command || (exports2.Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
      })(TextEdit = exports2.TextEdit || (exports2.TextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && VersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit = exports2.TextDocumentEdit || (exports2.TextDocumentEdit = {}));
      var TextEditChangeImpl = function() {
        function TextEditChangeImpl2(edits) {
          this.edits = edits;
        }
        TextEditChangeImpl2.prototype.insert = function(position, newText) {
          this.edits.push(TextEdit.insert(position, newText));
        };
        TextEditChangeImpl2.prototype.replace = function(range, newText) {
          this.edits.push(TextEdit.replace(range, newText));
        };
        TextEditChangeImpl2.prototype.delete = function(range) {
          this.edits.push(TextEdit.del(range));
        };
        TextEditChangeImpl2.prototype.add = function(edit) {
          this.edits.push(edit);
        };
        TextEditChangeImpl2.prototype.all = function() {
          return this.edits;
        };
        TextEditChangeImpl2.prototype.clear = function() {
          this.edits.splice(0, this.edits.length);
        };
        return TextEditChangeImpl2;
      }();
      var WorkspaceChange = function() {
        function WorkspaceChange2(workspaceEdit) {
          var _this = this;
          this._textEditChanges = /* @__PURE__ */ Object.create(null);
          if (workspaceEdit) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
              workspaceEdit.documentChanges.forEach(function(textDocumentEdit) {
                var textEditChange = new TextEditChangeImpl(textDocumentEdit.edits);
                _this._textEditChanges[textDocumentEdit.textDocument.uri] = textEditChange;
              });
            } else if (workspaceEdit.changes) {
              Object.keys(workspaceEdit.changes).forEach(function(key) {
                var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                _this._textEditChanges[key] = textEditChange;
              });
            }
          }
        }
        Object.defineProperty(WorkspaceChange2.prototype, "edit", {
          get: function() {
            return this._workspaceEdit;
          },
          enumerable: true,
          configurable: true
        });
        WorkspaceChange2.prototype.getTextEditChange = function(key) {
          if (VersionedTextDocumentIdentifier.is(key)) {
            if (!this._workspaceEdit) {
              this._workspaceEdit = {
                documentChanges: []
              };
            }
            if (!this._workspaceEdit.documentChanges) {
              throw new Error("Workspace edit is not configured for versioned document changes.");
            }
            var textDocument = key;
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
              var edits = [];
              var textDocumentEdit = {
                textDocument,
                edits
              };
              this._workspaceEdit.documentChanges.push(textDocumentEdit);
              result = new TextEditChangeImpl(edits);
              this._textEditChanges[textDocument.uri] = result;
            }
            return result;
          } else {
            if (!this._workspaceEdit) {
              this._workspaceEdit = {
                changes: /* @__PURE__ */ Object.create(null)
              };
            }
            if (!this._workspaceEdit.changes) {
              throw new Error("Workspace edit is not configured for normal text edit changes.");
            }
            var result = this._textEditChanges[key];
            if (!result) {
              var edits = [];
              this._workspaceEdit.changes[key] = edits;
              result = new TextEditChangeImpl(edits);
              this._textEditChanges[key] = result;
            }
            return result;
          }
        };
        return WorkspaceChange2;
      }();
      exports2.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier = exports2.TextDocumentIdentifier || (exports2.TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.number(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem = exports2.TextDocumentItem || (exports2.TextDocumentItem = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
      })(CompletionItemKind = exports2.CompletionItemKind || (exports2.CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat = exports2.InsertTextFormat || (exports2.InsertTextFormat = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem = exports2.CompletionItem || (exports2.CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList = exports2.CompletionList || (exports2.CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
      })(MarkedString = exports2.MarkedString || (exports2.MarkedString = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
        ;
      })(ParameterInformation = exports2.ParameterInformation || (exports2.ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation = exports2.SignatureInformation || (exports2.SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind = exports2.DocumentHighlightKind || (exports2.DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight = exports2.DocumentHighlight || (exports2.DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
      })(SymbolKind = exports2.SymbolKind || (exports2.SymbolKind = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation = exports2.SymbolInformation || (exports2.SymbolInformation = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics) {
          return { diagnostics };
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext = exports2.CodeActionContext || (exports2.CodeActionContext = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data))
            result.data = data;
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens = exports2.CodeLens || (exports2.CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions = exports2.FormattingOptions || (exports2.FormattingOptions = {}));
      var DocumentLink = function() {
        function DocumentLink2() {
        }
        return DocumentLink2;
      }();
      exports2.DocumentLink = DocumentLink;
      (function(DocumentLink2) {
        function create(range, target) {
          return { range, target };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink = exports2.DocumentLink || (exports2.DocumentLink = {}));
      exports2.DocumentLink = DocumentLink;
      exports2.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
      })(TextDocument = exports2.TextDocument || (exports2.TextDocument = {}));
      var TextDocumentSaveReason;
      (function(TextDocumentSaveReason2) {
        TextDocumentSaveReason2.Manual = 1;
        TextDocumentSaveReason2.AfterDelay = 2;
        TextDocumentSaveReason2.FocusOut = 3;
      })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
      var FullTextDocument = function() {
        function FullTextDocument2(uri, languageId, version, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version;
          this._content = content;
          this._lineOffsets = null;
        }
        Object.defineProperty(FullTextDocument2.prototype, "uri", {
          get: function() {
            return this._uri;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "languageId", {
          get: function() {
            return this._languageId;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "version", {
          get: function() {
            return this._version;
          },
          enumerable: true,
          configurable: true
        });
        FullTextDocument2.prototype.getText = function() {
          return this._content;
        };
        FullTextDocument2.prototype.update = function(event, version) {
          this._content = event.text;
          this._version = version;
          this._lineOffsets = null;
        };
        FullTextDocument2.prototype.getLineOffsets = function() {
          if (this._lineOffsets === null) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
              if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
              }
              var ch = text.charAt(i);
              isLineStart = ch === "\r" || ch === "\n";
              if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                i++;
              }
            }
            if (isLineStart && text.length > 0) {
              lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
          }
          return this._lineOffsets;
        };
        FullTextDocument2.prototype.positionAt = function(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          var lineOffsets = this.getLineOffsets();
          var low = 0, high = lineOffsets.length;
          if (high === 0) {
            return Position.create(0, offset);
          }
          while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          var line = low - 1;
          return Position.create(line, offset - lineOffsets[line]);
        };
        FullTextDocument2.prototype.offsetAt = function(position) {
          var lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          var lineOffset = lineOffsets[position.line];
          var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        };
        Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
          get: function() {
            return this.getLineOffsets().length;
          },
          enumerable: true,
          configurable: true
        });
        return FullTextDocument2;
      }();
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var toString = Object.prototype.toString;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return toString.call(value) === "[object String]";
    }
    exports.string = string;
    function number(value) {
      return toString.call(value) === "[object Number]";
    }
    exports.number = number;
    function error(value) {
      return toString.call(value) === "[object Error]";
    }
    exports.error = error;
    function func(value) {
      return toString.call(value) === "[object Function]";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports.thenable = thenable;
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Is = require_is2();
    var vscode_jsonrpc_1 = require_main();
    var DocumentFilter;
    (function(DocumentFilter2) {
      function is(value) {
        let candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
      }
      DocumentFilter2.is = is;
    })(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.type = new vscode_jsonrpc_1.RequestType("client/registerCapability");
    })(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.type = new vscode_jsonrpc_1.RequestType("client/unregisterCapability");
    })(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.type = new vscode_jsonrpc_1.RequestType("initialize");
    })(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
    var InitializeError;
    (function(InitializeError2) {
      InitializeError2.unknownProtocolVersion = 1;
    })(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.type = new vscode_jsonrpc_1.NotificationType("initialized");
    })(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.type = new vscode_jsonrpc_1.RequestType0("shutdown");
    })(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.type = new vscode_jsonrpc_1.NotificationType0("exit");
    })(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.type = new vscode_jsonrpc_1.NotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.type = new vscode_jsonrpc_1.NotificationType("window/showMessage");
    })(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.type = new vscode_jsonrpc_1.RequestType("window/showMessageRequest");
    })(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.type = new vscode_jsonrpc_1.NotificationType("window/logMessage");
    })(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.type = new vscode_jsonrpc_1.NotificationType("telemetry/event");
    })(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.type = new vscode_jsonrpc_1.NotificationType("textDocument/didOpen");
    })(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.type = new vscode_jsonrpc_1.NotificationType("textDocument/didChange");
    })(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.type = new vscode_jsonrpc_1.NotificationType("textDocument/didClose");
    })(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.type = new vscode_jsonrpc_1.NotificationType("textDocument/didSave");
    })(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.type = new vscode_jsonrpc_1.NotificationType("textDocument/willSave");
    })(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/willSaveWaitUntil");
    })(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.type = new vscode_jsonrpc_1.NotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.type = new vscode_jsonrpc_1.NotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/completion");
    })(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.type = new vscode_jsonrpc_1.RequestType("completionItem/resolve");
    })(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/hover");
    })(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/signatureHelp");
    })(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/definition");
    })(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/references");
    })(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/documentHighlight");
    })(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/documentSymbol");
    })(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.type = new vscode_jsonrpc_1.RequestType("workspace/symbol");
    })(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/codeAction");
    })(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/codeLens");
    })(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.type = new vscode_jsonrpc_1.RequestType("codeLens/resolve");
    })(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/formatting");
    })(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/rangeFormatting");
    })(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/onTypeFormatting");
    })(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/rename");
    })(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/documentLink");
    })(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.type = new vscode_jsonrpc_1.RequestType("documentLink/resolve");
    })(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.type = new vscode_jsonrpc_1.RequestType("workspace/executeCommand");
    })(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.type = new vscode_jsonrpc_1.RequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.configuration.proposed.js
var require_protocol_configuration_proposed = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.configuration.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.type = new vscode_jsonrpc_1.RequestType("workspace/configuration");
    })(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.proposed.js
var require_protocol_workspaceFolders_proposed = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.type = new vscode_jsonrpc_1.RequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.type = new vscode_jsonrpc_1.NotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.proposed.js
var require_protocol_colorProvider_proposed = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/documentColor");
    })(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.type = new vscode_jsonrpc_1.RequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/main.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
    exports.ResponseError = vscode_jsonrpc_1.ResponseError;
    exports.CancellationToken = vscode_jsonrpc_1.CancellationToken;
    exports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
    exports.Disposable = vscode_jsonrpc_1.Disposable;
    exports.Event = vscode_jsonrpc_1.Event;
    exports.Emitter = vscode_jsonrpc_1.Emitter;
    exports.Trace = vscode_jsonrpc_1.Trace;
    exports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
    exports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
    exports.RequestType = vscode_jsonrpc_1.RequestType;
    exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
    exports.NotificationType = vscode_jsonrpc_1.NotificationType;
    exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
    exports.MessageReader = vscode_jsonrpc_1.MessageReader;
    exports.MessageWriter = vscode_jsonrpc_1.MessageWriter;
    exports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
    exports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
    exports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
    exports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
    exports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
    exports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
    exports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
    exports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
    exports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
    exports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
    __export(require_main2());
    __export(require_protocol());
    var config = require_protocol_configuration_proposed();
    var folders = require_protocol_workspaceFolders_proposed();
    var color = require_protocol_colorProvider_proposed();
    var Proposed;
    (function(Proposed2) {
      let ConfigurationRequest;
      (function(ConfigurationRequest2) {
        ConfigurationRequest2.type = config.ConfigurationRequest.type;
      })(ConfigurationRequest = Proposed2.ConfigurationRequest || (Proposed2.ConfigurationRequest = {}));
      ;
      let WorkspaceFoldersRequest;
      (function(WorkspaceFoldersRequest2) {
        WorkspaceFoldersRequest2.type = folders.WorkspaceFoldersRequest.type;
      })(WorkspaceFoldersRequest = Proposed2.WorkspaceFoldersRequest || (Proposed2.WorkspaceFoldersRequest = {}));
      let DidChangeWorkspaceFoldersNotification;
      (function(DidChangeWorkspaceFoldersNotification2) {
        DidChangeWorkspaceFoldersNotification2.type = folders.DidChangeWorkspaceFoldersNotification.type;
      })(DidChangeWorkspaceFoldersNotification = Proposed2.DidChangeWorkspaceFoldersNotification || (Proposed2.DidChangeWorkspaceFoldersNotification = {}));
      Proposed2.DocumentColorRequest = color.DocumentColorRequest;
      Proposed2.ColorPresentationRequest = color.ColorPresentationRequest;
    })(Proposed = exports.Proposed || (exports.Proposed = {}));
    function createProtocolConnection(reader, writer, logger, strategy) {
      return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver/lib/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver/lib/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var toString = Object.prototype.toString;
    function defined(value) {
      return typeof value !== "undefined";
    }
    exports.defined = defined;
    function undefined2(value) {
      return typeof value === "undefined";
    }
    exports.undefined = undefined2;
    function nil(value) {
      return value === null;
    }
    exports.nil = nil;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return toString.call(value) === "[object String]";
    }
    exports.string = string;
    function number(value) {
      return toString.call(value) === "[object Number]";
    }
    exports.number = number;
    function error(value) {
      return toString.call(value) === "[object Error]";
    }
    exports.error = error;
    function func(value) {
      return toString.call(value) === "[object Function]";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports.thenable = thenable;
  }
});

// node_modules/vscode-languageserver/lib/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageserver/lib/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class extends ValueUUID {
      constructor() {
        super([
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          "4",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._oneOf(V4UUID._timeHighBits),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageserver/lib/files.js
var require_files = __commonJS({
  "node_modules/vscode-languageserver/lib/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var url = require("url");
    var path2 = require("path");
    var fs2 = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path2.normalize(segments.join("/"));
    }
    exports.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolveModule(workspaceRoot, moduleName) {
      let nodePathKey = "NODE_PATH";
      return new Promise((resolve3, reject) => {
        let nodePath = [];
        if (workspaceRoot) {
          nodePath.push(path2.join(workspaceRoot, "node_modules"));
        }
        child_process_1.exec("npm config get prefix", (error, stdout, _stderr) => {
          if (!error) {
            let globalPath = stdout.replace(/[\s\r\n]+$/, "");
            if (globalPath.length > 0) {
              if (isWindows()) {
                nodePath.push(path2.join(globalPath, "node_modules"));
              } else {
                nodePath.push(path2.join(globalPath, "lib", "node_modules"));
              }
            }
          }
          let separator = isWindows() ? ";" : ":";
          let env = process.env;
          let newEnv = /* @__PURE__ */ Object.create(null);
          Object.keys(env).forEach((key) => newEnv[key] = env[key]);
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath.join(separator) + separator + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath.join(separator);
          }
          try {
            let cp = child_process_1.fork(path2.join(__dirname, "resolve.js"), [], { env: newEnv, execArgv: [] });
            cp.on("message", (message2) => {
              if (message2.command === "resolve") {
                let toRequire = moduleName;
                if (message2.success) {
                  toRequire = message2.result;
                }
                cp.send({ command: "exit" });
                try {
                  resolve3(require(toRequire));
                } catch (error2) {
                  reject(error2);
                }
              }
            });
            let message = {
              command: "resolve",
              args: moduleName
            };
            cp.send(message);
          } catch (error2) {
            reject(error2);
          }
        });
      });
    }
    exports.resolveModule = resolveModule;
    function resolve2(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve3, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path2.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ATOM_SHELL_INTERNAL_RUN_AS_NODE"] = "1";
        try {
          let cp = child_process_1.fork("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve3(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports.resolve = resolve2;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = isWindows() ? "npm.cmd" : "npm";
      let stdout = child_process_1.spawnSync(npmCommand, ["config", "get", "prefix"], {
        encoding: "utf8"
      }).stdout;
      if (!stdout) {
        if (tracer) {
          tracer(`'npm config get prefix' didn't return a value.`);
        }
        return void 0;
      }
      let prefix = stdout.trim();
      if (tracer) {
        tracer(`'npm config get prefix' value is: ${prefix}`);
      }
      if (prefix.length > 0) {
        if (isWindows()) {
          return path2.join(prefix, "node_modules");
        } else {
          return path2.join(prefix, "lib", "node_modules");
        }
      }
      return void 0;
    }
    exports.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = isWindows() ? "yarn.cmd" : "yarn";
      let results = child_process_1.spawnSync(yarnCommand, ["global", "dir", "--json"], {
        encoding: "utf8"
      });
      let stdout = results.stdout;
      if (!stdout) {
        if (tracer) {
          tracer(`'yarn global dir' didn't return a value.`);
          if (results.stderr) {
            tracer(results.stderr);
          }
        }
        return void 0;
      }
      let lines = stdout.trim().split(/\r?\n/);
      for (let line of lines) {
        try {
          let yarn = JSON.parse(line);
          if (yarn.type === "log") {
            return path2.join(yarn.data, "node_modules");
          }
        } catch (e) {
        }
      }
      return void 0;
    }
    exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs2.existsSync(__filename.toUpperCase()) || !fs2.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path2.normalize(child).indexOf(path2.normalize(parent)) === 0;
        } else {
          return path2.normalize(child).toLowerCase().indexOf(path2.normalize(parent).toLowerCase()) == 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path2.isAbsolute(nodePath)) {
          nodePath = path2.join(workspaceRoot, nodePath);
        }
        return resolve2(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve2(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve2(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports.resolveModulePath = resolveModulePath;
    function resolveModule2(workspaceRoot, moduleName, nodePath, tracer) {
      return resolveModulePath(workspaceRoot, moduleName, nodePath, tracer).then((path3) => {
        if (tracer) {
          tracer(`Module ${moduleName} got resolved to ${path3}`);
        }
        return require(path3);
      });
    }
    exports.resolveModule2 = resolveModule2;
  }
});

// node_modules/vscode-languageserver/lib/configuration.proposed.js
var require_configuration_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/configuration.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is3();
    exports.ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.Proposed.ConfigurationRequest.type, params).then((result) => {
            return Array.isArray(arg) ? result : result[0];
          });
        }
      };
    };
  }
});

// node_modules/vscode-languageserver/lib/workspaceFolders.proposed.js
var require_workspaceFolders_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/workspaceFolders.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    exports.WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        initialize(capabilities) {
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.Proposed.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.Proposed.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.Proposed.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
  }
});

// node_modules/vscode-languageserver/lib/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageserver/lib/main.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    exports.Event = vscode_languageserver_protocol_1.Event;
    var Is = require_is3();
    var UUID = require_uuid();
    __export(require_main3());
    var fm = require_files();
    var Files2;
    (function(Files3) {
      Files3.uriToFilePath = fm.uriToFilePath;
      Files3.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files3.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files3.resolve = fm.resolve;
      Files3.resolveModule = fm.resolveModule;
      Files3.resolveModule2 = fm.resolveModule2;
      Files3.resolveModulePath = fm.resolveModulePath;
    })(Files2 = exports.Files || (exports.Files = {}));
    var shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                process.exit(shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var TextDocuments2 = class {
      constructor() {
        this._documents = /* @__PURE__ */ Object.create(null);
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      get syncKind() {
        return vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
      }
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onWillSave() {
        return this._onWillSave.event;
      }
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      get(uri) {
        return this._documents[uri];
      }
      all() {
        return Object.keys(this._documents).map((key) => this._documents[key]);
      }
      keys() {
        return Object.keys(this._documents);
      }
      listen(connection2) {
        function isUpdateableDocument(value) {
          return Is.func(value.update);
        }
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection2.onDidOpenTextDocument((event) => {
          let td = event.textDocument;
          let document = vscode_languageserver_protocol_1.TextDocument.create(td.uri, td.languageId, td.version, td.text);
          this._documents[td.uri] = document;
          let toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        });
        connection2.onDidChangeTextDocument((event) => {
          let td = event.textDocument;
          let changes = event.contentChanges;
          let last = changes.length > 0 ? changes[changes.length - 1] : void 0;
          if (last) {
            let document = this._documents[td.uri];
            if (document && isUpdateableDocument(document)) {
              document.update(last, td.version);
              this._onDidChangeContent.fire(Object.freeze({ document }));
            }
          }
        });
        connection2.onDidCloseTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            delete this._documents[event.textDocument.uri];
            this._onDidClose.fire(Object.freeze({ document }));
          }
        });
        connection2.onWillSaveTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
          }
        });
        connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let document = this._documents[event.textDocument.uri];
          if (document && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
          } else {
            return [];
          }
        });
        connection2.onDidSaveTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            this._onDidSave.fire(Object.freeze({ document }));
          }
        });
      }
    };
    exports.TextDocuments = TextDocuments2;
    var ErrorMessageTracker2 = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports.ErrorMessageTracker = ErrorMessageTracker2;
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(void 0, (_error) => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Unregistering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var ConnectionLogger = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
        }
      }
    };
    var RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params);
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this._connection);
        }
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method);
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(void 0, (_error) => {
          this.connection.console.info(`Unregistering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registeration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(edit) {
        let params = {
          edit
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this._connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this._connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
      }
    };
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
      };
      return result;
    }
    exports.combineFeatures = combineFeatures;
    function createConnection2(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let strategy;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (vscode_languageserver_protocol_1.ConnectionStrategy.is(arg1)) {
        strategy = arg1;
      } else {
        input = arg1;
        output = arg2;
        strategy = arg3;
      }
      return _createConnection(input, output, strategy, factories);
    }
    exports.createConnection = createConnection2;
    function _createConnection(input, output, strategy, factories) {
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new vscode_languageserver_protocol_1.IPCMessageReader(process);
            output = new vscode_languageserver_protocol_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = vscode_languageserver_protocol_1.createServerSocketTransport(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = vscode_languageserver_protocol_1.createServerPipeTransport(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          process.exit(shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          process.exit(shutdownReceived ? 0 : 1);
        });
      }
      const logger = factories && factories.console ? new (factories.console(ConnectionLogger))() : new ConnectionLogger();
      const connection2 = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger, strategy);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace];
      function asThenable(value) {
        if (Is.thenable(value)) {
          return value;
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, ...params) => connection2.sendNotification(Is.string(type) ? type : type.method, ...params),
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, handler),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, handler),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, handler),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, handler),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, handler),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, handler),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, handler),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, handler),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, handler),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, handler),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, handler),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, handler),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, handler),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, handler),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, handler),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, handler),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, handler),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        if (Is.number(params.processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(params.processId, 0);
            } catch (ex) {
              process.exit(shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token);
          return asThenable(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (!capabilities.textDocumentSync) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (shutdownReceived) {
            process.exit(0);
          } else {
            process.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    var config = require_configuration_proposed();
    var folders = require_workspaceFolders_proposed();
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.ConfigurationFeature = config.ConfigurationFeature;
      ProposedFeatures2.WorkspaceFoldersFeature = folders.WorkspaceFoldersFeature;
      ProposedFeatures2.all = {
        __brand: "features",
        workspace: combineWorkspaceFeatures(ProposedFeatures2.WorkspaceFoldersFeature, ProposedFeatures2.ConfigurationFeature)
      };
    })(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
  }
});

// node_modules/htmlhint/dist/core/htmlparser.js
var require_htmlparser = __commonJS({
  "node_modules/htmlhint/dist/core/htmlparser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HTMLParser = class {
      constructor() {
        this._listeners = {};
        this._mapCdataTags = this.makeMap("script,style");
        this._arrBlocks = [];
        this.lastEvent = null;
      }
      makeMap(str) {
        const obj = {};
        const items = str.split(",");
        for (let i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      parse(html) {
        const mapCdataTags = this._mapCdataTags;
        const regTag = /<(?:\/([^\s>]+)\s*|!--([\s\S]*?)--|!([^>]*?)|([\w\-:]+)((?:\s+[^\s"'>\/=\x00-\x0F\x7F\x80-\x9F]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s"'>]*))?)*?)\s*(\/?))>/g;
        const regAttr = /\s*([^\s"'>\/=\x00-\x0F\x7F\x80-\x9F]+)(?:\s*=\s*(?:(")([^"]*)"|(')([^']*)'|([^\s"'>]*)))?/g;
        const regLine = /\r?\n/g;
        let match;
        let matchIndex;
        let lastIndex = 0;
        let tagName;
        let arrAttrs;
        let tagCDATA = null;
        let attrsCDATA;
        let arrCDATA = [];
        let lastCDATAIndex = 0;
        let text;
        let lastLineIndex = 0;
        let line = 1;
        const arrBlocks = this._arrBlocks;
        this.fire("start", {
          pos: 0,
          line: 1,
          col: 1
        });
        const isMapCdataTagsRequired = () => {
          const attrType = arrAttrs.find((attr) => attr.name === "type") || {
            value: ""
          };
          return mapCdataTags[tagName] && attrType.value.indexOf("text/ng-template") === -1;
        };
        const saveBlock = (type, raw, pos, data) => {
          const col = pos - lastLineIndex + 1;
          if (data === void 0) {
            data = {};
          }
          data.raw = raw;
          data.pos = pos;
          data.line = line;
          data.col = col;
          arrBlocks.push(data);
          this.fire(type, data);
          while (regLine.exec(raw)) {
            line++;
            lastLineIndex = pos + regLine.lastIndex;
          }
        };
        while (match = regTag.exec(html)) {
          matchIndex = match.index;
          if (matchIndex > lastIndex) {
            text = html.substring(lastIndex, matchIndex);
            if (tagCDATA) {
              arrCDATA.push(text);
            } else {
              saveBlock("text", text, lastIndex);
            }
          }
          lastIndex = regTag.lastIndex;
          if (tagName = match[1]) {
            if (tagCDATA && tagName === tagCDATA) {
              text = arrCDATA.join("");
              saveBlock("cdata", text, lastCDATAIndex, {
                tagName: tagCDATA,
                attrs: attrsCDATA
              });
              tagCDATA = null;
              attrsCDATA = void 0;
              arrCDATA = [];
            }
            if (!tagCDATA) {
              saveBlock("tagend", match[0], matchIndex, {
                tagName
              });
              continue;
            }
          }
          if (tagCDATA) {
            arrCDATA.push(match[0]);
          } else {
            if (tagName = match[4]) {
              arrAttrs = [];
              const attrs = match[5];
              let attrMatch;
              let attrMatchCount = 0;
              while (attrMatch = regAttr.exec(attrs)) {
                const name = attrMatch[1];
                const quote = attrMatch[2] ? attrMatch[2] : attrMatch[4] ? attrMatch[4] : "";
                const value = attrMatch[3] ? attrMatch[3] : attrMatch[5] ? attrMatch[5] : attrMatch[6] ? attrMatch[6] : "";
                arrAttrs.push({
                  name,
                  value,
                  quote,
                  index: attrMatch.index,
                  raw: attrMatch[0]
                });
                attrMatchCount += attrMatch[0].length;
              }
              if (attrMatchCount === attrs.length) {
                saveBlock("tagstart", match[0], matchIndex, {
                  tagName,
                  attrs: arrAttrs,
                  close: match[6]
                });
                if (isMapCdataTagsRequired()) {
                  tagCDATA = tagName;
                  attrsCDATA = arrAttrs.concat();
                  arrCDATA = [];
                  lastCDATAIndex = lastIndex;
                }
              } else {
                saveBlock("text", match[0], matchIndex);
              }
            } else if (match[2] || match[3]) {
              saveBlock("comment", match[0], matchIndex, {
                content: match[2] || match[3],
                long: match[2] ? true : false
              });
            }
          }
        }
        if (html.length > lastIndex) {
          text = html.substring(lastIndex, html.length);
          saveBlock("text", text, lastIndex);
        }
        this.fire("end", {
          pos: lastIndex,
          line,
          col: html.length - lastLineIndex + 1
        });
      }
      addListener(types, listener) {
        const _listeners = this._listeners;
        const arrTypes = types.split(/[,\s]/);
        let type;
        for (let i = 0, l = arrTypes.length; i < l; i++) {
          type = arrTypes[i];
          if (_listeners[type] === void 0) {
            _listeners[type] = [];
          }
          _listeners[type].push(listener);
        }
      }
      fire(type, data) {
        if (data === void 0) {
          data = {};
        }
        data.type = type;
        let listeners = [];
        const listenersType = this._listeners[type];
        const listenersAll = this._listeners["all"];
        if (listenersType !== void 0) {
          listeners = listeners.concat(listenersType);
        }
        if (listenersAll !== void 0) {
          listeners = listeners.concat(listenersAll);
        }
        const lastEvent = this.lastEvent;
        if (lastEvent !== null) {
          delete lastEvent["lastEvent"];
          data.lastEvent = lastEvent;
        }
        this.lastEvent = data;
        for (let i = 0, l = listeners.length; i < l; i++) {
          listeners[i].call(this, data);
        }
      }
      removeListener(type, listener) {
        const listenersType = this._listeners[type];
        if (listenersType !== void 0) {
          for (let i = 0, l = listenersType.length; i < l; i++) {
            if (listenersType[i] === listener) {
              listenersType.splice(i, 1);
              break;
            }
          }
        }
      }
      fixPos(event, index) {
        const text = event.raw.substr(0, index);
        const arrLines = text.split(/\r?\n/);
        const lineCount = arrLines.length - 1;
        let line = event.line;
        let col;
        if (lineCount > 0) {
          line += lineCount;
          col = arrLines[lineCount].length + 1;
        } else {
          col = event.col + index;
        }
        return {
          line,
          col
        };
      }
      getMapAttrs(arrAttrs) {
        const mapAttrs = {};
        let attr;
        for (let i = 0, l = arrAttrs.length; i < l; i++) {
          attr = arrAttrs[i];
          mapAttrs[attr.name] = attr.value;
        }
        return mapAttrs;
      }
    };
    exports.default = HTMLParser;
  }
});

// node_modules/htmlhint/dist/core/reporter.js
var require_reporter = __commonJS({
  "node_modules/htmlhint/dist/core/reporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Reporter = class {
      constructor(html, ruleset) {
        this.html = html;
        this.lines = html.split(/\r?\n/);
        const match = /\r?\n/.exec(html);
        this.brLen = match !== null ? match[0].length : 0;
        this.ruleset = ruleset;
        this.messages = [];
      }
      info(message, line, col, rule, raw) {
        this.report("info", message, line, col, rule, raw);
      }
      warn(message, line, col, rule, raw) {
        this.report("warning", message, line, col, rule, raw);
      }
      error(message, line, col, rule, raw) {
        this.report("error", message, line, col, rule, raw);
      }
      report(type, message, line, col, rule, raw) {
        const lines = this.lines;
        const brLen = this.brLen;
        let evidence = "";
        let evidenceLen = 0;
        for (let i = line - 1, lineCount = lines.length; i < lineCount; i++) {
          evidence = lines[i];
          evidenceLen = evidence.length;
          if (col > evidenceLen && line < lineCount) {
            line++;
            col -= evidenceLen;
            if (col !== 1) {
              col -= brLen;
            }
          } else {
            break;
          }
        }
        this.messages.push({
          type,
          message,
          raw,
          evidence,
          line,
          col,
          rule: {
            id: rule.id,
            description: rule.description,
            link: `https://htmlhint.com/docs/user-guide/rules/${rule.id}`
          }
        });
      }
    };
    exports.default = Reporter;
  }
});

// node_modules/htmlhint/dist/core/rules/alt-require.js
var require_alt_require = __commonJS({
  "node_modules/htmlhint/dist/core/rules/alt-require.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "alt-require",
      description: "The alt attribute of an <img> element must be present and alt attribute of area[href] and input[type=image] must have a value.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const tagName = event.tagName.toLowerCase();
          const mapAttrs = parser.getMapAttrs(event.attrs);
          const col = event.col + tagName.length + 1;
          let selector;
          if (tagName === "img" && !("alt" in mapAttrs)) {
            reporter.warn("An alt attribute must be present on <img> elements.", event.line, col, this, event.raw);
          } else if (tagName === "area" && "href" in mapAttrs || tagName === "input" && mapAttrs["type"] === "image") {
            if (!("alt" in mapAttrs) || mapAttrs["alt"] === "") {
              selector = tagName === "area" ? "area[href]" : "input[type=image]";
              reporter.warn(`The alt attribute of ${selector} must have a value.`, event.line, col, this, event.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-lowercase.js
var require_attr_lowercase = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-lowercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var svgIgnores = [
      "allowReorder",
      "attributeName",
      "attributeType",
      "autoReverse",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPath",
      "clipPathUnits",
      "contentScriptType",
      "contentStyleType",
      "diffuseConstant",
      "edgeMode",
      "externalResourcesRequired",
      "filterRes",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "onBlur",
      "onChange",
      "onClick",
      "onFocus",
      "onKeyUp",
      "onLoad",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ];
    function testAgainstStringOrRegExp(value, comparison) {
      if (comparison instanceof RegExp) {
        return comparison.test(value) ? { match: value, pattern: comparison } : false;
      }
      const firstComparisonChar = comparison[0];
      const lastComparisonChar = comparison[comparison.length - 1];
      const secondToLastComparisonChar = comparison[comparison.length - 2];
      const comparisonIsRegex = firstComparisonChar === "/" && (lastComparisonChar === "/" || secondToLastComparisonChar === "/" && lastComparisonChar === "i");
      const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === "i";
      if (comparisonIsRegex) {
        const valueMatches = hasCaseInsensitiveFlag ? new RegExp(comparison.slice(1, -2), "i").test(value) : new RegExp(comparison.slice(1, -1)).test(value);
        return valueMatches;
      }
      return value === comparison;
    }
    exports.default = {
      id: "attr-lowercase",
      description: "All attribute names must be in lowercase.",
      init(parser, reporter, options) {
        const exceptions = (Array.isArray(options) ? options : []).concat(svgIgnores);
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            const attrName = attr.name;
            if (!exceptions.find((exp) => testAgainstStringOrRegExp(attrName, exp)) && attrName !== attrName.toLowerCase()) {
              reporter.error(`The attribute name of [ ${attrName} ] must be in lowercase.`, event.line, col + attr.index, this, attr.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-sorted.js
var require_attr_sorted = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-sorted.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "attr-sorted",
      description: "Attribute tags must be in proper order.",
      init(parser, reporter) {
        const orderMap = {};
        const sortOrder = [
          "class",
          "id",
          "name",
          "src",
          "for",
          "type",
          "href",
          "value",
          "title",
          "alt",
          "role"
        ];
        for (let i = 0; i < sortOrder.length; i++) {
          orderMap[sortOrder[i]] = i;
        }
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          const listOfAttributes = [];
          for (let i = 0; i < attrs.length; i++) {
            listOfAttributes.push(attrs[i].name);
          }
          const originalAttrs = JSON.stringify(listOfAttributes);
          listOfAttributes.sort((a, b) => {
            if (orderMap[a] == void 0 && orderMap[b] == void 0) {
              return 0;
            }
            if (orderMap[a] == void 0) {
              return 1;
            } else if (orderMap[b] == void 0) {
              return -1;
            }
            return orderMap[a] - orderMap[b] || a.localeCompare(b);
          });
          if (originalAttrs !== JSON.stringify(listOfAttributes)) {
            reporter.error(`Inaccurate order ${originalAttrs} should be in hierarchy ${JSON.stringify(listOfAttributes)} `, event.line, event.col, this, event.raw);
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-no-duplication.js
var require_attr_no_duplication = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-no-duplication.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "attr-no-duplication",
      description: "Elements cannot have duplicate attributes.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          let attrName;
          const col = event.col + event.tagName.length + 1;
          const mapAttrName = {};
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            attrName = attr.name;
            if (mapAttrName[attrName] === true) {
              reporter.error(`Duplicate of attribute name [ ${attr.name} ] was found.`, event.line, col + attr.index, this, attr.raw);
            }
            mapAttrName[attrName] = true;
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-unsafe-chars.js
var require_attr_unsafe_chars = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-unsafe-chars.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "attr-unsafe-chars",
      description: "Attribute values cannot contain unsafe chars.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          const regUnsafe = /[\u0000-\u0008\u000b\u000c\u000e-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;
          let match;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            match = regUnsafe.exec(attr.value);
            if (match !== null) {
              const unsafeCode = escape(match[0]).replace(/%u/, "\\u").replace(/%/, "\\x");
              reporter.warn(`The value of attribute [ ${attr.name} ] cannot contain an unsafe char [ ${unsafeCode} ].`, event.line, col + attr.index, this, attr.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-value-double-quotes.js
var require_attr_value_double_quotes = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-value-double-quotes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "attr-value-double-quotes",
      description: "Attribute values must be in double quotes.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            if (attr.value !== "" && attr.quote !== '"' || attr.value === "" && attr.quote === "'") {
              reporter.error(`The value of attribute [ ${attr.name} ] must be in double quotes.`, event.line, col + attr.index, this, attr.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-value-not-empty.js
var require_attr_value_not_empty = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-value-not-empty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "attr-value-not-empty",
      description: "All attributes must have values.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            if (attr.quote === "" && attr.value === "") {
              reporter.warn(`The attribute [ ${attr.name} ] must have a value.`, event.line, col + attr.index, this, attr.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-value-single-quotes.js
var require_attr_value_single_quotes = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-value-single-quotes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "attr-value-single-quotes",
      description: "Attribute values must be in single quotes.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            if (attr.value !== "" && attr.quote !== "'" || attr.value === "" && attr.quote === '"') {
              reporter.error(`The value of attribute [ ${attr.name} ] must be in single quotes.`, event.line, col + attr.index, this, attr.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-whitespace.js
var require_attr_whitespace = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "attr-whitespace",
      description: "All attributes should be separated by only one space and not have leading/trailing whitespace.",
      init(parser, reporter, options) {
        const exceptions = Array.isArray(options) ? options : [];
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          attrs.forEach((elem) => {
            attr = elem;
            const attrName = elem.name;
            if (exceptions.indexOf(attrName) !== -1) {
              return;
            }
            if (elem.value.trim() !== elem.value) {
              reporter.error(`The attributes of [ ${attrName} ] must not have leading or trailing whitespace.`, event.line, col + attr.index, this, attr.raw);
            }
            if (elem.value.replace(/ +(?= )/g, "") !== elem.value) {
              reporter.error(`The attributes of [ ${attrName} ] must be separated by only one space.`, event.line, col + attr.index, this, attr.raw);
            }
          });
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/doctype-first.js
var require_doctype_first = __commonJS({
  "node_modules/htmlhint/dist/core/rules/doctype-first.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "doctype-first",
      description: "Doctype must be declared first.",
      init(parser, reporter) {
        const allEvent = (event) => {
          if (event.type === "start" || event.type === "text" && /^\s*$/.test(event.raw)) {
            return;
          }
          if (event.type !== "comment" && event.long === false || /^DOCTYPE\s+/i.test(event.content) === false) {
            reporter.error("Doctype must be declared first.", event.line, event.col, this, event.raw);
          }
          parser.removeListener("all", allEvent);
        };
        parser.addListener("all", allEvent);
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/doctype-html5.js
var require_doctype_html5 = __commonJS({
  "node_modules/htmlhint/dist/core/rules/doctype-html5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "doctype-html5",
      description: 'Invalid doctype. Use: "<!DOCTYPE html>"',
      init(parser, reporter) {
        const onComment = (event) => {
          if (event.long === false && event.content.toLowerCase() !== "doctype html") {
            reporter.warn('Invalid doctype. Use: "<!DOCTYPE html>"', event.line, event.col, this, event.raw);
          }
        };
        const onTagStart = () => {
          parser.removeListener("comment", onComment);
          parser.removeListener("tagstart", onTagStart);
        };
        parser.addListener("all", onComment);
        parser.addListener("tagstart", onTagStart);
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/head-script-disabled.js
var require_head_script_disabled = __commonJS({
  "node_modules/htmlhint/dist/core/rules/head-script-disabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "head-script-disabled",
      description: "The <script> tag cannot be used in a <head> tag.",
      init(parser, reporter) {
        const reScript = /^(text\/javascript|application\/javascript)$/i;
        let isInHead = false;
        const onTagStart = (event) => {
          const mapAttrs = parser.getMapAttrs(event.attrs);
          const type = mapAttrs.type;
          const tagName = event.tagName.toLowerCase();
          if (tagName === "head") {
            isInHead = true;
          }
          if (isInHead === true && tagName === "script" && (!type || reScript.test(type) === true)) {
            reporter.warn("The <script> tag cannot be used in a <head> tag.", event.line, event.col, this, event.raw);
          }
        };
        const onTagEnd = (event) => {
          if (event.tagName.toLowerCase() === "head") {
            parser.removeListener("tagstart", onTagStart);
            parser.removeListener("tagend", onTagEnd);
          }
        };
        parser.addListener("tagstart", onTagStart);
        parser.addListener("tagend", onTagEnd);
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/href-abs-or-rel.js
var require_href_abs_or_rel = __commonJS({
  "node_modules/htmlhint/dist/core/rules/href-abs-or-rel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "href-abs-or-rel",
      description: "An href attribute must be either absolute or relative.",
      init(parser, reporter, options) {
        const hrefMode = options === "abs" ? "absolute" : "relative";
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            if (attr.name === "href") {
              if (hrefMode === "absolute" && /^\w+?:/.test(attr.value) === false || hrefMode === "relative" && /^https?:\/\//.test(attr.value) === true) {
                reporter.warn(`The value of the href attribute [ ${attr.value} ] must be ${hrefMode}.`, event.line, col + attr.index, this, attr.raw);
              }
              break;
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/html-lang-require.js
var require_html_lang_require = __commonJS({
  "node_modules/htmlhint/dist/core/rules/html-lang-require.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var regular = "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)";
    var irregular = "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)";
    var grandfathered = `(?<grandfathered>${irregular}|${regular})`;
    var privateUse = "(?<privateUse>x(-[A-Za-z0-9]{1,8})+)";
    var privateUse2 = "(?<privateUse2>x(-[A-Za-z0-9]{1,8})+)";
    var singleton = "[0-9A-WY-Za-wy-z]";
    var extension = `(?<extension>${singleton}(-[A-Za-z0-9]{2,8})+)`;
    var variant = "(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3})";
    var region = "(?<region>[A-Za-z]{2}|[0-9]{3})";
    var script = "(?<script>[A-Za-z]{4})";
    var extlang = "(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2})";
    var language = `(?<language>([A-Za-z]{2,3}(-${extlang})?)|[A-Za-z]{4}|[A-Za-z]{5,8})`;
    var langtag = `(${language}(-${script})?(-${region})?(-${variant})*(-${extension})*(-${privateUse})?)`;
    var languageTag = `(${grandfathered}|${langtag}|${privateUse2})`;
    exports.default = {
      id: "html-lang-require",
      description: "The lang attribute of an <html> element must be present and should be valid.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const tagName = event.tagName.toLowerCase();
          const mapAttrs = parser.getMapAttrs(event.attrs);
          const col = event.col + tagName.length + 1;
          const langValidityPattern = new RegExp(languageTag, "g");
          if (tagName === "html") {
            if ("lang" in mapAttrs) {
              if (!mapAttrs["lang"]) {
                reporter.warn("The lang attribute of <html> element must have a value.", event.line, col, this, event.raw);
              } else if (!langValidityPattern.test(mapAttrs["lang"])) {
                reporter.warn("The lang attribute value of <html> element must be a valid BCP47.", event.line, col, this, event.raw);
              }
            } else {
              reporter.warn("An lang attribute must be present on <html> elements.", event.line, col, this, event.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/id-class-ad-disabled.js
var require_id_class_ad_disabled = __commonJS({
  "node_modules/htmlhint/dist/core/rules/id-class-ad-disabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "id-class-ad-disabled",
      description: "The id and class attributes cannot use the ad keyword, it will be blocked by adblock software.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          let attrName;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            attrName = attr.name;
            if (/^(id|class)$/i.test(attrName)) {
              if (/(^|[-_])ad([-_]|$)/i.test(attr.value)) {
                reporter.warn(`The value of attribute ${attrName} cannot use the ad keyword.`, event.line, col + attr.index, this, attr.raw);
              }
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/id-class-value.js
var require_id_class_value = __commonJS({
  "node_modules/htmlhint/dist/core/rules/id-class-value.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "id-class-value",
      description: "The id and class attribute values must meet the specified rules.",
      init(parser, reporter, options) {
        const arrRules = {
          underline: {
            regId: /^[a-z\d]+(_[a-z\d]+)*$/,
            message: "The id and class attribute values must be in lowercase and split by an underscore."
          },
          dash: {
            regId: /^[a-z\d]+(-[a-z\d]+)*$/,
            message: "The id and class attribute values must be in lowercase and split by a dash."
          },
          hump: {
            regId: /^[a-z][a-zA-Z\d]*([A-Z][a-zA-Z\d]*)*$/,
            message: "The id and class attribute values must meet the camelCase style."
          }
        };
        let rule;
        if (typeof options === "string") {
          rule = arrRules[options];
        } else {
          rule = options;
        }
        if (typeof rule === "object" && rule.regId) {
          let regId = rule.regId;
          const message = rule.message;
          if (!(regId instanceof RegExp)) {
            regId = new RegExp(regId);
          }
          parser.addListener("tagstart", (event) => {
            const attrs = event.attrs;
            let attr;
            const col = event.col + event.tagName.length + 1;
            for (let i = 0, l1 = attrs.length; i < l1; i++) {
              attr = attrs[i];
              if (attr.name.toLowerCase() === "id") {
                if (regId.test(attr.value) === false) {
                  reporter.warn(message, event.line, col + attr.index, this, attr.raw);
                }
              }
              if (attr.name.toLowerCase() === "class") {
                const arrClass = attr.value.split(/\s+/g);
                let classValue;
                for (let j = 0, l2 = arrClass.length; j < l2; j++) {
                  classValue = arrClass[j];
                  if (classValue && regId.test(classValue) === false) {
                    reporter.warn(message, event.line, col + attr.index, this, classValue);
                  }
                }
              }
            }
          });
        }
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/id-unique.js
var require_id_unique = __commonJS({
  "node_modules/htmlhint/dist/core/rules/id-unique.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "id-unique",
      description: "The value of id attributes must be unique.",
      init(parser, reporter) {
        const mapIdCount = {};
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          let id;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            if (attr.name.toLowerCase() === "id") {
              id = attr.value;
              if (id) {
                if (mapIdCount[id] === void 0) {
                  mapIdCount[id] = 1;
                } else {
                  mapIdCount[id]++;
                }
                if (mapIdCount[id] > 1) {
                  reporter.error(`The id value [ ${id} ] must be unique.`, event.line, col + attr.index, this, attr.raw);
                }
              }
              break;
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/inline-script-disabled.js
var require_inline_script_disabled = __commonJS({
  "node_modules/htmlhint/dist/core/rules/inline-script-disabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "inline-script-disabled",
      description: "Inline script cannot be used.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          let attrName;
          const reEvent = /^on(unload|message|submit|select|scroll|resize|mouseover|mouseout|mousemove|mouseleave|mouseenter|mousedown|load|keyup|keypress|keydown|focus|dblclick|click|change|blur|error)$/i;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            attrName = attr.name.toLowerCase();
            if (reEvent.test(attrName) === true) {
              reporter.warn(`Inline script [ ${attr.raw} ] cannot be used.`, event.line, col + attr.index, this, attr.raw);
            } else if (attrName === "src" || attrName === "href") {
              if (/^\s*javascript:/i.test(attr.value)) {
                reporter.warn(`Inline script [ ${attr.raw} ] cannot be used.`, event.line, col + attr.index, this, attr.raw);
              }
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/inline-style-disabled.js
var require_inline_style_disabled = __commonJS({
  "node_modules/htmlhint/dist/core/rules/inline-style-disabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "inline-style-disabled",
      description: "Inline style cannot be used.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          let attr;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            if (attr.name.toLowerCase() === "style") {
              reporter.warn(`Inline style [ ${attr.raw} ] cannot be used.`, event.line, col + attr.index, this, attr.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/input-requires-label.js
var require_input_requires_label = __commonJS({
  "node_modules/htmlhint/dist/core/rules/input-requires-label.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "input-requires-label",
      description: "All [ input ] tags must have a corresponding [ label ] tag. ",
      init(parser, reporter) {
        const labelTags = [];
        const inputTags = [];
        parser.addListener("tagstart", (event) => {
          const tagName = event.tagName.toLowerCase();
          const mapAttrs = parser.getMapAttrs(event.attrs);
          const col = event.col + tagName.length + 1;
          if (tagName === "input") {
            if (mapAttrs["type"] !== "hidden") {
              inputTags.push({ event, col, id: mapAttrs["id"] });
            }
          }
          if (tagName === "label") {
            if ("for" in mapAttrs && mapAttrs["for"] !== "") {
              labelTags.push({ event, col, forValue: mapAttrs["for"] });
            }
          }
        });
        parser.addListener("end", () => {
          inputTags.forEach((inputTag) => {
            if (!hasMatchingLabelTag(inputTag)) {
              reporter.warn("No matching [ label ] tag found.", inputTag.event.line, inputTag.col, this, inputTag.event.raw);
            }
          });
        });
        function hasMatchingLabelTag(inputTag) {
          let found = false;
          labelTags.forEach((labelTag) => {
            if (inputTag.id && inputTag.id === labelTag.forValue) {
              found = true;
            }
          });
          return found;
        }
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/script-disabled.js
var require_script_disabled = __commonJS({
  "node_modules/htmlhint/dist/core/rules/script-disabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "script-disabled",
      description: "The <script> tag cannot be used.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          if (event.tagName.toLowerCase() === "script") {
            reporter.error("The <script> tag cannot be used.", event.line, event.col, this, event.raw);
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/space-tab-mixed-disabled.js
var require_space_tab_mixed_disabled = __commonJS({
  "node_modules/htmlhint/dist/core/rules/space-tab-mixed-disabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "space-tab-mixed-disabled",
      description: "Do not mix tabs and spaces for indentation.",
      init(parser, reporter, options) {
        let indentMode = "nomix";
        let spaceLengthRequire = null;
        if (typeof options === "string") {
          const match = /^([a-z]+)(\d+)?/.exec(options);
          if (match) {
            indentMode = match[1];
            spaceLengthRequire = match[2] && parseInt(match[2], 10);
          }
        }
        parser.addListener("text", (event) => {
          const raw = event.raw;
          const reMixed = /(^|\r?\n)([ \t]+)/g;
          let match;
          while (match = reMixed.exec(raw)) {
            const fixedPos = parser.fixPos(event, match.index + match[1].length);
            if (fixedPos.col !== 1) {
              continue;
            }
            const whiteSpace = match[2];
            if (indentMode === "space") {
              if (spaceLengthRequire) {
                if (/^ +$/.test(whiteSpace) === false || whiteSpace.length % spaceLengthRequire !== 0) {
                  reporter.warn(`Please use space for indentation and keep ${spaceLengthRequire} length.`, fixedPos.line, 1, this, event.raw);
                }
              } else {
                if (/^ +$/.test(whiteSpace) === false) {
                  reporter.warn("Please use space for indentation.", fixedPos.line, 1, this, event.raw);
                }
              }
            } else if (indentMode === "tab" && /^\t+$/.test(whiteSpace) === false) {
              reporter.warn("Please use tab for indentation.", fixedPos.line, 1, this, event.raw);
            } else if (/ +\t|\t+ /.test(whiteSpace) === true) {
              reporter.warn("Do not mix tabs and spaces for indentation.", fixedPos.line, 1, this, event.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/spec-char-escape.js
var require_spec_char_escape = __commonJS({
  "node_modules/htmlhint/dist/core/rules/spec-char-escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "spec-char-escape",
      description: "Special characters must be escaped.",
      init(parser, reporter) {
        parser.addListener("text", (event) => {
          const raw = event.raw;
          const reSpecChar = /([<>])|( \& )/g;
          let match;
          while (match = reSpecChar.exec(raw)) {
            const fixedPos = parser.fixPos(event, match.index);
            reporter.error(`Special characters must be escaped : [ ${match[0]} ].`, fixedPos.line, fixedPos.col, this, event.raw);
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/src-not-empty.js
var require_src_not_empty = __commonJS({
  "node_modules/htmlhint/dist/core/rules/src-not-empty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "src-not-empty",
      description: "The src attribute of an img(script,link) must have a value.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          const tagName = event.tagName;
          const attrs = event.attrs;
          let attr;
          const col = event.col + tagName.length + 1;
          for (let i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];
            if ((/^(img|script|embed|bgsound|iframe)$/.test(tagName) === true && attr.name === "src" || tagName === "link" && attr.name === "href" || tagName === "object" && attr.name === "data") && attr.value === "") {
              reporter.error(`The attribute [ ${attr.name} ] of the tag [ ${tagName} ] must have a value.`, event.line, col + attr.index, this, attr.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/style-disabled.js
var require_style_disabled = __commonJS({
  "node_modules/htmlhint/dist/core/rules/style-disabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "style-disabled",
      description: "<style> tags cannot be used.",
      init(parser, reporter) {
        parser.addListener("tagstart", (event) => {
          if (event.tagName.toLowerCase() === "style") {
            reporter.warn("The <style> tag cannot be used.", event.line, event.col, this, event.raw);
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/tag-pair.js
var require_tag_pair = __commonJS({
  "node_modules/htmlhint/dist/core/rules/tag-pair.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "tag-pair",
      description: "Tag must be paired.",
      init(parser, reporter) {
        const stack = [];
        const mapEmptyTags = parser.makeMap("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr");
        parser.addListener("tagstart", (event) => {
          const tagName = event.tagName.toLowerCase();
          if (mapEmptyTags[tagName] === void 0 && !event.close) {
            stack.push({
              tagName,
              line: event.line,
              raw: event.raw
            });
          }
        });
        parser.addListener("tagend", (event) => {
          const tagName = event.tagName.toLowerCase();
          let pos;
          for (pos = stack.length - 1; pos >= 0; pos--) {
            if (stack[pos].tagName === tagName) {
              break;
            }
          }
          if (pos >= 0) {
            const arrTags = [];
            for (let i = stack.length - 1; i > pos; i--) {
              arrTags.push(`</${stack[i].tagName}>`);
            }
            if (arrTags.length > 0) {
              const lastEvent = stack[stack.length - 1];
              reporter.error(`Tag must be paired, missing: [ ${arrTags.join("")} ], start tag match failed [ ${lastEvent.raw} ] on line ${lastEvent.line}.`, event.line, event.col, this, event.raw);
            }
            stack.length = pos;
          } else {
            reporter.error(`Tag must be paired, no start tag: [ ${event.raw} ]`, event.line, event.col, this, event.raw);
          }
        });
        parser.addListener("end", (event) => {
          const arrTags = [];
          for (let i = stack.length - 1; i >= 0; i--) {
            arrTags.push(`</${stack[i].tagName}>`);
          }
          if (arrTags.length > 0) {
            const lastEvent = stack[stack.length - 1];
            reporter.error(`Tag must be paired, missing: [ ${arrTags.join("")} ], open tag match failed [ ${lastEvent.raw} ] on line ${lastEvent.line}.`, event.line, event.col, this, "");
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/tag-self-close.js
var require_tag_self_close = __commonJS({
  "node_modules/htmlhint/dist/core/rules/tag-self-close.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "tag-self-close",
      description: "Empty tags must be self closed.",
      init(parser, reporter) {
        const mapEmptyTags = parser.makeMap("area,base,basefont,bgsound,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr");
        parser.addListener("tagstart", (event) => {
          const tagName = event.tagName.toLowerCase();
          if (mapEmptyTags[tagName] !== void 0) {
            if (!event.close) {
              reporter.warn(`The empty tag : [ ${tagName} ] must be self closed.`, event.line, event.col, this, event.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/empty-tag-not-self-closed.js
var require_empty_tag_not_self_closed = __commonJS({
  "node_modules/htmlhint/dist/core/rules/empty-tag-not-self-closed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "empty-tag-not-self-closed",
      description: "Empty tags must not use self closed syntax.",
      init(parser, reporter) {
        const mapEmptyTags = parser.makeMap("area,base,basefont,bgsound,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr");
        parser.addListener("tagstart", (event) => {
          const tagName = event.tagName.toLowerCase();
          if (mapEmptyTags[tagName] !== void 0) {
            if (event.close) {
              reporter.error(`The empty tag : [ ${tagName} ] must not use self closed syntax.`, event.line, event.col, this, event.raw);
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/tagname-lowercase.js
var require_tagname_lowercase = __commonJS({
  "node_modules/htmlhint/dist/core/rules/tagname-lowercase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "tagname-lowercase",
      description: "All html element names must be in lowercase.",
      init(parser, reporter, options) {
        const exceptions = Array.isArray(options) ? options : [];
        parser.addListener("tagstart,tagend", (event) => {
          const tagName = event.tagName;
          if (exceptions.indexOf(tagName) === -1 && tagName !== tagName.toLowerCase()) {
            reporter.error(`The html element name of [ ${tagName} ] must be in lowercase.`, event.line, event.col, this, event.raw);
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/tagname-specialchars.js
var require_tagname_specialchars = __commonJS({
  "node_modules/htmlhint/dist/core/rules/tagname-specialchars.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "tagname-specialchars",
      description: "All special characters must be escaped.",
      init(parser, reporter) {
        const specialchars = /[^a-zA-Z0-9\-:_]/;
        parser.addListener("tagstart,tagend", (event) => {
          const tagName = event.tagName;
          if (specialchars.test(tagName)) {
            reporter.error(`The html element name of [ ${tagName} ] contains special character.`, event.line, event.col, this, event.raw);
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/title-require.js
var require_title_require = __commonJS({
  "node_modules/htmlhint/dist/core/rules/title-require.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "title-require",
      description: "<title> must be present in <head> tag.",
      init(parser, reporter) {
        let headBegin = false;
        let hasTitle = false;
        const onTagStart = (event) => {
          const tagName = event.tagName.toLowerCase();
          if (tagName === "head") {
            headBegin = true;
          } else if (tagName === "title" && headBegin) {
            hasTitle = true;
          }
        };
        const onTagEnd = (event) => {
          const tagName = event.tagName.toLowerCase();
          if (hasTitle && tagName === "title") {
            const lastEvent = event.lastEvent;
            if (lastEvent.type !== "text" || lastEvent.type === "text" && /^\s*$/.test(lastEvent.raw) === true) {
              reporter.error("<title></title> must not be empty.", event.line, event.col, this, event.raw);
            }
          } else if (tagName === "head") {
            if (hasTitle === false) {
              reporter.error("<title> must be present in <head> tag.", event.line, event.col, this, event.raw);
            }
            parser.removeListener("tagstart", onTagStart);
            parser.removeListener("tagend", onTagEnd);
          }
        };
        parser.addListener("tagstart", onTagStart);
        parser.addListener("tagend", onTagEnd);
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/tags-check.js
var require_tags_check = __commonJS({
  "node_modules/htmlhint/dist/core/rules/tags-check.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tagsTypings = {
      a: {
        selfclosing: false,
        attrsRequired: ["href", "title"],
        redundantAttrs: ["alt"]
      },
      div: {
        selfclosing: false
      },
      main: {
        selfclosing: false,
        redundantAttrs: ["role"]
      },
      nav: {
        selfclosing: false,
        redundantAttrs: ["role"]
      },
      script: {
        attrsOptional: [
          ["async", "async"],
          ["defer", "defer"]
        ]
      },
      img: {
        selfclosing: true,
        attrsRequired: ["src", "alt", "title"]
      }
    };
    exports.default = {
      id: "tags-check",
      description: "Checks html tags.",
      init(parser, reporter, options) {
        tagsTypings = Object.assign(Object.assign({}, tagsTypings), options);
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          const col = event.col + event.tagName.length + 1;
          const tagName = event.tagName.toLowerCase();
          if (tagsTypings[tagName]) {
            const currentTagType = tagsTypings[tagName];
            if (currentTagType.selfclosing === true && !event.close) {
              reporter.warn(`The <${tagName}> tag must be selfclosing.`, event.line, event.col, this, event.raw);
            } else if (currentTagType.selfclosing === false && event.close) {
              reporter.warn(`The <${tagName}> tag must not be selfclosing.`, event.line, event.col, this, event.raw);
            }
            if (Array.isArray(currentTagType.attrsRequired)) {
              const attrsRequired = currentTagType.attrsRequired;
              attrsRequired.forEach((id) => {
                if (Array.isArray(id)) {
                  const copyOfId = id.map((a) => a);
                  const realID = copyOfId.shift();
                  const values = copyOfId;
                  if (attrs.some((attr) => attr.name === realID)) {
                    attrs.forEach((attr) => {
                      if (attr.name === realID && values.indexOf(attr.value) === -1) {
                        reporter.error(`The <${tagName}> tag must have attr '${realID}' with one value of '${values.join("' or '")}'.`, event.line, col, this, event.raw);
                      }
                    });
                  } else {
                    reporter.error(`The <${tagName}> tag must have attr '${realID}'.`, event.line, col, this, event.raw);
                  }
                } else if (!attrs.some((attr) => id.split("|").indexOf(attr.name) !== -1)) {
                  reporter.error(`The <${tagName}> tag must have attr '${id}'.`, event.line, col, this, event.raw);
                }
              });
            }
            if (Array.isArray(currentTagType.attrsOptional)) {
              const attrsOptional = currentTagType.attrsOptional;
              attrsOptional.forEach((id) => {
                if (Array.isArray(id)) {
                  const copyOfId = id.map((a) => a);
                  const realID = copyOfId.shift();
                  const values = copyOfId;
                  if (attrs.some((attr) => attr.name === realID)) {
                    attrs.forEach((attr) => {
                      if (attr.name === realID && values.indexOf(attr.value) === -1) {
                        reporter.error(`The <${tagName}> tag must have optional attr '${realID}' with one value of '${values.join("' or '")}'.`, event.line, col, this, event.raw);
                      }
                    });
                  }
                }
              });
            }
            if (Array.isArray(currentTagType.redundantAttrs)) {
              const redundantAttrs = currentTagType.redundantAttrs;
              redundantAttrs.forEach((attrName) => {
                if (attrs.some((attr) => attr.name === attrName)) {
                  reporter.error(`The attr '${attrName}' is redundant for <${tagName}> and should be omitted.`, event.line, col, this, event.raw);
                }
              });
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/attr-no-unnecessary-whitespace.js
var require_attr_no_unnecessary_whitespace = __commonJS({
  "node_modules/htmlhint/dist/core/rules/attr-no-unnecessary-whitespace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      id: "attr-no-unnecessary-whitespace",
      description: "No spaces between attribute names and values.",
      init(parser, reporter, options) {
        const exceptions = Array.isArray(options) ? options : [];
        parser.addListener("tagstart", (event) => {
          const attrs = event.attrs;
          const col = event.col + event.tagName.length + 1;
          for (let i = 0; i < attrs.length; i++) {
            if (exceptions.indexOf(attrs[i].name) === -1) {
              const match = /(\s*)=(\s*)/.exec(attrs[i].raw.trim());
              if (match && (match[1].length !== 0 || match[2].length !== 0)) {
                reporter.error(`The attribute '${attrs[i].name}' must not have spaces between the name and value.`, event.line, col + attrs[i].index, this, attrs[i].raw);
              }
            }
          }
        });
      }
    };
  }
});

// node_modules/htmlhint/dist/core/rules/index.js
var require_rules = __commonJS({
  "node_modules/htmlhint/dist/core/rules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attrNoUnnecessaryWhitespace = exports.tagsCheck = exports.titleRequire = exports.tagnameSpecialChars = exports.tagnameLowercase = exports.emptyTagNotSelfClosed = exports.tagSelfClose = exports.tagPair = exports.styleDisabled = exports.srcNotEmpty = exports.specCharEscape = exports.spaceTabMixedDisabled = exports.scriptDisabled = exports.inputRequiresLabel = exports.inlineStyleDisabled = exports.inlineScriptDisabled = exports.idUnique = exports.idClassValue = exports.idClsasAdDisabled = exports.htmlLangRequire = exports.hrefAbsOrRel = exports.headScriptDisabled = exports.doctypeHTML5 = exports.doctypeFirst = exports.attrWhitespace = exports.attrValueSingleQuotes = exports.attrValueNotEmpty = exports.attrValueDoubleQuotes = exports.attrUnsafeChars = exports.attrNoDuplication = exports.attrSort = exports.attrLowercase = exports.altRequire = void 0;
    var alt_require_1 = require_alt_require();
    Object.defineProperty(exports, "altRequire", { enumerable: true, get: function() {
      return alt_require_1.default;
    } });
    var attr_lowercase_1 = require_attr_lowercase();
    Object.defineProperty(exports, "attrLowercase", { enumerable: true, get: function() {
      return attr_lowercase_1.default;
    } });
    var attr_sorted_1 = require_attr_sorted();
    Object.defineProperty(exports, "attrSort", { enumerable: true, get: function() {
      return attr_sorted_1.default;
    } });
    var attr_no_duplication_1 = require_attr_no_duplication();
    Object.defineProperty(exports, "attrNoDuplication", { enumerable: true, get: function() {
      return attr_no_duplication_1.default;
    } });
    var attr_unsafe_chars_1 = require_attr_unsafe_chars();
    Object.defineProperty(exports, "attrUnsafeChars", { enumerable: true, get: function() {
      return attr_unsafe_chars_1.default;
    } });
    var attr_value_double_quotes_1 = require_attr_value_double_quotes();
    Object.defineProperty(exports, "attrValueDoubleQuotes", { enumerable: true, get: function() {
      return attr_value_double_quotes_1.default;
    } });
    var attr_value_not_empty_1 = require_attr_value_not_empty();
    Object.defineProperty(exports, "attrValueNotEmpty", { enumerable: true, get: function() {
      return attr_value_not_empty_1.default;
    } });
    var attr_value_single_quotes_1 = require_attr_value_single_quotes();
    Object.defineProperty(exports, "attrValueSingleQuotes", { enumerable: true, get: function() {
      return attr_value_single_quotes_1.default;
    } });
    var attr_whitespace_1 = require_attr_whitespace();
    Object.defineProperty(exports, "attrWhitespace", { enumerable: true, get: function() {
      return attr_whitespace_1.default;
    } });
    var doctype_first_1 = require_doctype_first();
    Object.defineProperty(exports, "doctypeFirst", { enumerable: true, get: function() {
      return doctype_first_1.default;
    } });
    var doctype_html5_1 = require_doctype_html5();
    Object.defineProperty(exports, "doctypeHTML5", { enumerable: true, get: function() {
      return doctype_html5_1.default;
    } });
    var head_script_disabled_1 = require_head_script_disabled();
    Object.defineProperty(exports, "headScriptDisabled", { enumerable: true, get: function() {
      return head_script_disabled_1.default;
    } });
    var href_abs_or_rel_1 = require_href_abs_or_rel();
    Object.defineProperty(exports, "hrefAbsOrRel", { enumerable: true, get: function() {
      return href_abs_or_rel_1.default;
    } });
    var html_lang_require_1 = require_html_lang_require();
    Object.defineProperty(exports, "htmlLangRequire", { enumerable: true, get: function() {
      return html_lang_require_1.default;
    } });
    var id_class_ad_disabled_1 = require_id_class_ad_disabled();
    Object.defineProperty(exports, "idClsasAdDisabled", { enumerable: true, get: function() {
      return id_class_ad_disabled_1.default;
    } });
    var id_class_value_1 = require_id_class_value();
    Object.defineProperty(exports, "idClassValue", { enumerable: true, get: function() {
      return id_class_value_1.default;
    } });
    var id_unique_1 = require_id_unique();
    Object.defineProperty(exports, "idUnique", { enumerable: true, get: function() {
      return id_unique_1.default;
    } });
    var inline_script_disabled_1 = require_inline_script_disabled();
    Object.defineProperty(exports, "inlineScriptDisabled", { enumerable: true, get: function() {
      return inline_script_disabled_1.default;
    } });
    var inline_style_disabled_1 = require_inline_style_disabled();
    Object.defineProperty(exports, "inlineStyleDisabled", { enumerable: true, get: function() {
      return inline_style_disabled_1.default;
    } });
    var input_requires_label_1 = require_input_requires_label();
    Object.defineProperty(exports, "inputRequiresLabel", { enumerable: true, get: function() {
      return input_requires_label_1.default;
    } });
    var script_disabled_1 = require_script_disabled();
    Object.defineProperty(exports, "scriptDisabled", { enumerable: true, get: function() {
      return script_disabled_1.default;
    } });
    var space_tab_mixed_disabled_1 = require_space_tab_mixed_disabled();
    Object.defineProperty(exports, "spaceTabMixedDisabled", { enumerable: true, get: function() {
      return space_tab_mixed_disabled_1.default;
    } });
    var spec_char_escape_1 = require_spec_char_escape();
    Object.defineProperty(exports, "specCharEscape", { enumerable: true, get: function() {
      return spec_char_escape_1.default;
    } });
    var src_not_empty_1 = require_src_not_empty();
    Object.defineProperty(exports, "srcNotEmpty", { enumerable: true, get: function() {
      return src_not_empty_1.default;
    } });
    var style_disabled_1 = require_style_disabled();
    Object.defineProperty(exports, "styleDisabled", { enumerable: true, get: function() {
      return style_disabled_1.default;
    } });
    var tag_pair_1 = require_tag_pair();
    Object.defineProperty(exports, "tagPair", { enumerable: true, get: function() {
      return tag_pair_1.default;
    } });
    var tag_self_close_1 = require_tag_self_close();
    Object.defineProperty(exports, "tagSelfClose", { enumerable: true, get: function() {
      return tag_self_close_1.default;
    } });
    var empty_tag_not_self_closed_1 = require_empty_tag_not_self_closed();
    Object.defineProperty(exports, "emptyTagNotSelfClosed", { enumerable: true, get: function() {
      return empty_tag_not_self_closed_1.default;
    } });
    var tagname_lowercase_1 = require_tagname_lowercase();
    Object.defineProperty(exports, "tagnameLowercase", { enumerable: true, get: function() {
      return tagname_lowercase_1.default;
    } });
    var tagname_specialchars_1 = require_tagname_specialchars();
    Object.defineProperty(exports, "tagnameSpecialChars", { enumerable: true, get: function() {
      return tagname_specialchars_1.default;
    } });
    var title_require_1 = require_title_require();
    Object.defineProperty(exports, "titleRequire", { enumerable: true, get: function() {
      return title_require_1.default;
    } });
    var tags_check_1 = require_tags_check();
    Object.defineProperty(exports, "tagsCheck", { enumerable: true, get: function() {
      return tags_check_1.default;
    } });
    var attr_no_unnecessary_whitespace_1 = require_attr_no_unnecessary_whitespace();
    Object.defineProperty(exports, "attrNoUnnecessaryWhitespace", { enumerable: true, get: function() {
      return attr_no_unnecessary_whitespace_1.default;
    } });
  }
});

// node_modules/htmlhint/dist/core/core.js
var require_core = __commonJS({
  "node_modules/htmlhint/dist/core/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HTMLParser = exports.Reporter = exports.HTMLRules = exports.HTMLHint = void 0;
    var htmlparser_1 = require_htmlparser();
    exports.HTMLParser = htmlparser_1.default;
    var reporter_1 = require_reporter();
    exports.Reporter = reporter_1.default;
    var HTMLRules = require_rules();
    exports.HTMLRules = HTMLRules;
    var HTMLHintCore = class {
      constructor() {
        this.rules = {};
        this.defaultRuleset = {
          "tagname-lowercase": true,
          "attr-lowercase": true,
          "attr-value-double-quotes": true,
          "doctype-first": true,
          "tag-pair": true,
          "spec-char-escape": true,
          "id-unique": true,
          "src-not-empty": true,
          "attr-no-duplication": true,
          "title-require": true
        };
      }
      addRule(rule) {
        this.rules[rule.id] = rule;
      }
      verify(html, ruleset = this.defaultRuleset) {
        if (Object.keys(ruleset).length === 0) {
          ruleset = this.defaultRuleset;
        }
        html = html.replace(/^\s*<!--\s*htmlhint\s+([^\r\n]+?)\s*-->/i, (all, strRuleset) => {
          strRuleset.replace(/(?:^|,)\s*([^:,]+)\s*(?:\:\s*([^,\s]+))?/g, (all2, ruleId, value) => {
            ruleset[ruleId] = value !== void 0 && value.length > 0 ? JSON.parse(value) : true;
            return "";
          });
          return "";
        });
        const parser = new htmlparser_1.default();
        const reporter = new reporter_1.default(html, ruleset);
        const rules = this.rules;
        let rule;
        for (const id in ruleset) {
          rule = rules[id];
          if (rule !== void 0 && ruleset[id] !== false) {
            rule.init(parser, reporter, ruleset[id]);
          }
        }
        parser.parse(html);
        return reporter.messages;
      }
      format(arrMessages, options = {}) {
        const arrLogs = [];
        const colors = {
          white: "",
          grey: "",
          red: "",
          reset: ""
        };
        if (options.colors) {
          colors.white = "\x1B[37m";
          colors.grey = "\x1B[90m";
          colors.red = "\x1B[31m";
          colors.reset = "\x1B[39m";
        }
        const indent = options.indent || 0;
        arrMessages.forEach((hint) => {
          const leftWindow = 40;
          const rightWindow = leftWindow + 20;
          let evidence = hint.evidence;
          const line = hint.line;
          const col = hint.col;
          const evidenceCount = evidence.length;
          let leftCol = col > leftWindow + 1 ? col - leftWindow : 1;
          let rightCol = evidence.length > col + rightWindow ? col + rightWindow : evidenceCount;
          if (col < leftWindow + 1) {
            rightCol += leftWindow - col + 1;
          }
          evidence = evidence.replace(/\t/g, " ").substring(leftCol - 1, rightCol);
          if (leftCol > 1) {
            evidence = `...${evidence}`;
            leftCol -= 3;
          }
          if (rightCol < evidenceCount) {
            evidence += "...";
          }
          arrLogs.push(`${colors.white + repeatStr(indent)}L${line} |${colors.grey}${evidence}${colors.reset}`);
          let pointCol = col - leftCol;
          const match = evidence.substring(0, pointCol).match(/[^\u0000-\u00ff]/g);
          if (match !== null) {
            pointCol += match.length;
          }
          arrLogs.push(`${colors.white + repeatStr(indent) + repeatStr(String(line).length + 3 + pointCol)}^ ${colors.red}${hint.message} (${hint.rule.id})${colors.reset}`);
        });
        return arrLogs;
      }
    };
    function repeatStr(n, str) {
      return new Array(n + 1).join(str || " ");
    }
    exports.HTMLHint = new HTMLHintCore();
    Object.keys(HTMLRules).forEach((key) => {
      exports.HTMLHint.addRule(HTMLRules[key]);
    });
  }
});

// node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "node_modules/strip-json-comments/index.js"(exports, module2) {
    "use strict";
    var singleComment = Symbol("singleComment");
    var multiComment = Symbol("multiComment");
    var stripWithoutWhitespace = () => "";
    var stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\S/g, " ");
    var isEscaped = (jsonString, quotePosition) => {
      let index = quotePosition - 1;
      let backslashCount = 0;
      while (jsonString[index] === "\\") {
        index -= 1;
        backslashCount += 1;
      }
      return Boolean(backslashCount % 2);
    };
    module2.exports = (jsonString, options = {}) => {
      if (typeof jsonString !== "string") {
        throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
      }
      const strip = options.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      let insideString = false;
      let insideComment = false;
      let offset = 0;
      let result = "";
      for (let i = 0; i < jsonString.length; i++) {
        const currentCharacter = jsonString[i];
        const nextCharacter = jsonString[i + 1];
        if (!insideComment && currentCharacter === '"') {
          const escaped = isEscaped(jsonString, i);
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentCharacter + nextCharacter === "//") {
          result += jsonString.slice(offset, i);
          offset = i;
          insideComment = singleComment;
          i++;
        } else if (insideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
          i++;
          insideComment = false;
          result += strip(jsonString, offset, i);
          offset = i;
          continue;
        } else if (insideComment === singleComment && currentCharacter === "\n") {
          insideComment = false;
          result += strip(jsonString, offset, i);
          offset = i;
        } else if (!insideComment && currentCharacter + nextCharacter === "/*") {
          result += jsonString.slice(offset, i);
          offset = i;
          insideComment = multiComment;
          i++;
          continue;
        } else if (insideComment === multiComment && currentCharacter + nextCharacter === "*/") {
          i++;
          insideComment = false;
          result += strip(jsonString, offset, i + 1);
          offset = i + 1;
          continue;
        }
      }
      return result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
    };
  }
});

// src/server/server.ts
var path = __toESM(require("path"));
var server = __toESM(require_main4());
var htmlhint = __toESM(require_core());
var import_strip_json_comments = __toESM(require_strip_json_comments());
var fs = require("fs");
var settings;
var linter = null;
var htmlhintrcOptions = {};
function getRange(error, lines) {
  const line = lines[error.line - 1];
  let isWhitespace = false;
  let curr = error.col;
  while (curr < line.length && !isWhitespace) {
    const char = line[curr];
    isWhitespace = char === " " || char === "	" || char === "\n" || char === "\r" || char === "<";
    ++curr;
  }
  if (isWhitespace) {
    --curr;
  }
  return {
    start: {
      line: error.line - 1,
      character: error.col - 1
    },
    end: {
      line: error.line - 1,
      character: curr
    }
  };
}
function makeDiagnostic(problem, lines) {
  return {
    severity: server.DiagnosticSeverity.Warning,
    message: problem.message,
    range: getRange(problem, lines),
    code: problem.rule.id
  };
}
function getConfiguration(filePath) {
  let options;
  if (settings.htmlhint) {
    if (settings.htmlhint.configFile && settings.htmlhint.options && Object.keys(settings.htmlhint.options).length > 0) {
      throw new Error(`The configuration settings for HTMLHint are invalid. Please specify either 'htmlhint.configFile' or 'htmlhint.options', but not both.`);
    }
    if (settings.htmlhint.configFile) {
      if (fs.existsSync(settings.htmlhint.configFile)) {
        options = loadConfigurationFile(settings.htmlhint.configFile);
      } else {
        const configFileHint = !path.isAbsolute(settings.htmlhint.configFile) ? ` (resolves to '${path.resolve(settings.htmlhint.configFile)}')` : "";
        throw new Error(`The configuration settings for HTMLHint are invalid. The file '${settings.htmlhint.configFile}'${configFileHint} specified in 'htmlhint.configFile' could not be found.`);
      }
    } else if (settings.htmlhint.options && Object.keys(settings.htmlhint.options).length > 0) {
      options = settings.htmlhint.options;
    } else {
      options = findConfigForHtmlFile(filePath);
    }
  } else {
    options = findConfigForHtmlFile(filePath);
  }
  options = options || {};
  return options;
}
function findConfigForHtmlFile(base) {
  let options;
  if (fs.existsSync(base)) {
    if (fs.statSync(base).isDirectory() === false) {
      base = path.dirname(base);
    }
    while (base && !options) {
      const tmpConfigFile = path.resolve(base + path.sep, ".htmlhintrc");
      if (htmlhintrcOptions[tmpConfigFile] === void 0) {
        htmlhintrcOptions[tmpConfigFile] = loadConfigurationFile(tmpConfigFile);
      }
      if (htmlhintrcOptions[tmpConfigFile]) {
        options = htmlhintrcOptions[tmpConfigFile];
        break;
      }
      base = base.substring(0, base.lastIndexOf(path.sep));
    }
  }
  return options;
}
function loadConfigurationFile(configFile) {
  let ruleset = null;
  if (fs.existsSync(configFile)) {
    const config = fs.readFileSync(configFile, "utf8");
    try {
      ruleset = JSON.parse((0, import_strip_json_comments.default)(config));
    } catch (e) {
    }
  }
  return ruleset;
}
function getErrorMessage(err, document) {
  let result;
  if (typeof err.message === "string" || err.message instanceof String) {
    result = err.message;
  } else {
    result = `An unknown error occured while validating file: ${server.Files.uriToFilePath(document.uri)}`;
  }
  return result;
}
function validateAllTextDocuments(connection2, documents2) {
  const tracker = new server.ErrorMessageTracker();
  documents2.forEach((document) => {
    try {
      validateTextDocument(connection2, document);
    } catch (err) {
      tracker.add(getErrorMessage(err, document));
    }
  });
  tracker.sendErrors(connection2);
}
function validateTextDocument(connection2, document) {
  try {
    doValidate(connection2, document);
  } catch (err) {
    connection2.window.showErrorMessage(getErrorMessage(err, document));
  }
}
var connection = server.createConnection();
var documents = new server.TextDocuments();
documents.listen(connection);
function trace(message, verbose) {
  connection.tracer.log(message, verbose);
}
connection.onInitialize((params, token) => {
  const rootFolder = params.rootPath || "";
  const initOptions = params.initializationOptions;
  const nodePath = initOptions ? initOptions.nodePath ? initOptions.nodePath : "" : "";
  const result = server.Files.resolveModule2(rootFolder, "htmlhint", nodePath, trace).then((value) => {
    linter = value.default || value.HTMLHint || value;
    const result2 = { capabilities: { textDocumentSync: documents.syncKind } };
    return result2;
  }, (error) => {
    linter = htmlhint.default || htmlhint.HTMLHint || htmlhint;
    const result2 = { capabilities: { textDocumentSync: documents.syncKind } };
    return result2;
  });
  return result;
});
function doValidate(connection2, document) {
  try {
    const uri = document.uri;
    const fsPath = server.Files.uriToFilePath(uri) || "";
    const contents = document.getText();
    const lines = contents.split("\n");
    const config = getConfiguration(fsPath);
    const errors = linter.verify(contents, config);
    const diagnostics = [];
    if (errors.length > 0) {
      errors.forEach((each) => {
        diagnostics.push(makeDiagnostic(each, lines));
      });
    }
    connection2.sendDiagnostics({ uri, diagnostics });
  } catch (err) {
    let message;
    if (typeof err.message === "string" || err.message instanceof String) {
      message = err.message;
      throw new Error(message);
    }
    throw err;
  }
}
documents.onDidChangeContent((event) => {
  validateTextDocument(connection, event.document);
});
connection.onDidChangeConfiguration((params) => {
  settings = params.settings;
  validateAllTextDocuments(connection, documents.all());
});
connection.onDidChangeWatchedFiles((params) => {
  for (let i = 0; i < params.changes.length; i++) {
    htmlhintrcOptions[server.Files.uriToFilePath(params.changes[i].uri)] = void 0;
  }
  validateAllTextDocuments(connection, documents.all());
});
connection.listen();
